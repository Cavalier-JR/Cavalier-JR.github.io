<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="计算机视觉,人工智能,深度学习,卷积神经网络,目标检测,边缘检测,特征提取,CV">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>计算机视觉知识点总结（结合cs131） | Fetyloi&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

    <script src="https://fastly.jsdelivr.net/npm/live2d-widgets@0/autoload.js"></script>
<meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Fetyloi's Blog" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Fetyloi&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>网址导航</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a target="_blank" rel="noopener" href="https://www.bing.com">
          
          <span>New Bing</span>
        </a>
      </li>
      
      <li>
        <a target="_blank" rel="noopener" href="https://chat.openai.com">
          
          <span>OpenAi</span>
        </a>
      </li>
      
      <li>
        <a href="/navigate">
          
          <span>Navigate</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a class="modal-trigger waves-effect waves-light" onclick="switchNightMode()" title="深浅主题切换" >
      <i id="sum-moon-icon" class="fas fa-moon" style="zoom: 0.7;"></i>
    </a>
  </li>
</ul>




<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Fetyloi&#39;s Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			网址导航
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a target="_blank" rel="noopener" href="https://www.bing.com " style="margin-left:75px">
				  
		          <span>New Bing</span>
                  </a>
                </li>
              
                <li>

                  <a target="_blank" rel="noopener" href="https://chat.openai.com " style="margin-left:75px">
				  
		          <span>OpenAi</span>
                  </a>
                </li>
              
                <li>

                  <a href="/navigate " style="margin-left:75px">
				  
		          <span>Navigate</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Cavalier-JR" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>嘻嘻
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Cavalier-JR" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="嘻嘻" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/../images/33.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">计算机视觉知识点总结（结合cs131）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 135px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">
                                <span class="chip bg-color">深度学习</span>
                            </a>
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">
                                <span class="chip bg-color">计算机视觉</span>
                            </a>
                        
                            <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">
                                <span class="chip bg-color">人工智能</span>
                            </a>
                        
                            <a href="/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">
                                <span class="chip bg-color">卷积神经网络</span>
                            </a>
                        
                            <a href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">
                                <span class="chip bg-color">目标检测</span>
                            </a>
                        
                            <a href="/tags/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/">
                                <span class="chip bg-color">边缘检测</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-04-25
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2025-04-25
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    19.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    70 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="〇、考点"><a href="#〇、考点" class="headerlink" title="〇、考点"></a>〇、考点</h1><blockquote>
<p><strong>题目主要集中在分割之前</strong></p>
</blockquote>
<h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h2><ul>
<li>知道几个计算机视觉的应用场景（选择题）</li>
</ul>
<h2 id="2-图像的形成"><a href="#2-图像的形成" class="headerlink" title="2. 图像的形成"></a>2. 图像的形成</h2><ul>
<li>颜色直方图的优缺点</li>
</ul>
<h2 id="3-图像处理基础"><a href="#3-图像处理基础" class="headerlink" title="3. 图像处理基础"></a>3. 图像处理基础</h2><ul>
<li>卷积时对边缘填坑问题的四种处理方式，对应matlab函数的意义</li>
<li>高斯核方差/窗宽的变化与平滑程度的关系（可能简答可能选择）</li>
<li>常见卷积核（原图、左移一个单位、模糊……）</li>
<li>高斯核的自卷积性质</li>
<li>卷积时间复杂度分析（强调了一定会考）</li>
</ul>
<h2 id="4-边缘检测"><a href="#4-边缘检测" class="headerlink" title="4. 边缘检测"></a>4. 边缘检测</h2><ul>
<li>解释为什么图像对x（y）求导提取了y（x）方向的特征</li>
<li>可分离性的证明，可能是高斯核，也可能是高斯一阶偏导核（一定会考）</li>
<li>3.10没声，不知道Canny边缘检测器的考点情况</li>
<li>霍夫变换和RANSAC的异同点？（简答）</li>
<li>霍夫变换的流程的大致描述</li>
<li>霍夫变换的优缺点（可能选择也可能问答）</li>
</ul>
<h2 id="5-拟合"><a href="#5-拟合" class="headerlink" title="5. 拟合"></a>5. 拟合</h2><ul>
<li>K-Means 算法的流程</li>
<li>K-Means 算法的优缺点</li>
<li>Mean Shift 算法的流程</li>
<li>Mean Shift 算法的优缺点</li>
</ul>
<h2 id="6-局部特征"><a href="#6-局部特征" class="headerlink" title="6. 局部特征"></a>6. 局部特征</h2><h3 id="（1）角点检测"><a href="#（1）角点检测" class="headerlink" title="（1）角点检测"></a>（1）角点检测</h3><ul>
<li>Harris角点检测的流程</li>
<li>M矩阵和阈值R如何计算</li>
<li>Harris角点检测的不变性</li>
</ul>
<h3 id="（2）斑点检测"><a href="#（2）斑点检测" class="headerlink" title="（2）斑点检测"></a>（2）斑点检测</h3><ul>
<li>高斯差分如何提升了计算效率</li>
<li>高斯核的性质（高斯核的自卷积性质）</li>
</ul>
<h3 id="（3）纹理特征"><a href="#（3）纹理特征" class="headerlink" title="（3）纹理特征"></a>（3）纹理特征</h3><ul>
<li>优点、属性（可能以选择题的形式）</li>
<li>SIFT特征的维度（128）</li>
<li>需要好好复习SIFT特征</li>
</ul>
<h2 id="7-分割"><a href="#7-分割" class="headerlink" title="7. 分割"></a>7. 分割</h2><p>不知道</p>
<h2 id="8-识别"><a href="#8-识别" class="headerlink" title="8. 识别"></a>8. 识别</h2><p>不知道</p>
<h2 id="9-检测"><a href="#9-检测" class="headerlink" title="9. 检测"></a>9. 检测</h2><ul>
<li>Boosting算法的思想</li>
<li>统计模板方法的优缺点（选择题）</li>
</ul>
<h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><h2 id="1-计算机视觉的目标"><a href="#1-计算机视觉的目标" class="headerlink" title="1. 计算机视觉的目标"></a>1. 计算机视觉的目标</h2><p>跨越“语义鸿沟”建立像素到语义的映射</p>
<h2 id="2-人类视觉系统"><a href="#2-人类视觉系统" class="headerlink" title="2. 人类视觉系统"></a>2. 人类视觉系统</h2><h3 id="（1）视觉流程"><a href="#（1）视觉流程" class="headerlink" title="（1）视觉流程"></a>（1）视觉流程</h3><p>图像/视频 → 眼睛【感知设备】 → 大脑【解释器】 → 花草树木 春夏秋冬 山河湖海…【解释】</p>
<h3 id="（2）能力"><a href="#（2）能力" class="headerlink" title="（2）能力"></a>（2）能力</h3><ul>
<li>运动视盲</li>
<li>分割</li>
<li>感知</li>
<li>….</li>
</ul>
<h3 id="（3）计算机视觉的应用场景"><a href="#（3）计算机视觉的应用场景" class="headerlink" title="（3）计算机视觉的应用场景"></a>（3）计算机视觉的应用场景</h3><ul>
<li>三维重建</li>
<li>人脸检测、笑容检测</li>
<li>虹膜识别、指纹识别</li>
<li>手写字体识别、车牌识别</li>
<li>无人超市</li>
<li>火星探测</li>
<li>医学图像辅助诊断</li>
<li>增强现实</li>
<li>虚拟现实</li>
<li>…….<blockquote>
<p>这部分没什么东西，略过</p>
</blockquote>
</li>
</ul>
<h1 id="二、图像的形成"><a href="#二、图像的形成" class="headerlink" title="二、图像的形成"></a>二、图像的形成</h1><h2 id="1-图像的类型"><a href="#1-图像的类型" class="headerlink" title="1. 图像的类型"></a>1. 图像的类型</h2><h3 id="（1）二进制图像"><a href="#（1）二进制图像" class="headerlink" title="（1）二进制图像"></a>（1）二进制图像</h3><p>每个像素点取值0/1；0黑，1白<br>每个像素点可以用1个bit表示<br><img src="/../images/post13_images/c577564971b79c29dc5958291aa7c1ab.png"></p>
<h3 id="（2）灰色图像"><a href="#（2）灰色图像" class="headerlink" title="（2）灰色图像"></a>（2）灰色图像</h3><p>每个像素点取值0~255；小黑，大白<br>每个像素点可以用1个byte表示（$1$ $byte$ = $2^8$ $bit$=256$ $bit$）<br><img src="/../images/post13_images/347e291fb5502947fa87fd2fb5a65d94.png"><br>灰度图像能表示的信息有限，比如车道的黄线和白线，灰度表示不出来</p>
<h3 id="（3）彩色图像"><a href="#（3）彩色图像" class="headerlink" title="（3）彩色图像"></a>（3）彩色图像</h3><h4 id="eg-RGB"><a href="#eg-RGB" class="headerlink" title="eg.RGB"></a>eg.RGB</h4><p>三个通道：Red/Green/Blue<br>每个像素点可以用3个byte表示</p>
<h2 id="2-数字图像的存储"><a href="#2-数字图像的存储" class="headerlink" title="2. 数字图像的存储"></a>2. 数字图像的存储</h2><blockquote>
<p>对数字图像进行采样和量化两个操作，从而表示为整数值矩阵</p>
</blockquote>
<h3 id="（1）采样"><a href="#（1）采样" class="headerlink" title="（1）采样"></a>（1）采样</h3><p>在一个规则的网格上对二维空间进行采样：</p>
<ul>
<li>把图像划分为非常多的小格子，格子越多，分辨率越高，每个格子表示一个像素<br><img src="/../images/post13_images/b6153f9813f5948f64910aef2bcedc50.png"></li>
</ul>
<h3 id="（2）量化"><a href="#（2）量化" class="headerlink" title="（2）量化"></a>（2）量化</h3><ul>
<li>给每个小格子（像素）一个整数值，0~255，数值连续<br><img src="/../images/post13_images/3d9d43a93052cd327031dc82bc9b8bbd.png"></li>
</ul>
<h2 id="3-图像色彩模型"><a href="#3-图像色彩模型" class="headerlink" title="3. 图像色彩模型"></a>3. 图像色彩模型</h2><h3 id="（1）色彩空间的定义"><a href="#（1）色彩空间的定义" class="headerlink" title="（1）色彩空间的定义"></a>（1）色彩空间的定义</h3><p>通过多个颜色分量构成坐标系来表示各种颜色的模型系统</p>
<h3 id="（2）常见的色彩空间"><a href="#（2）常见的色彩空间" class="headerlink" title="（2）常见的色彩空间"></a>（2）常见的色彩空间</h3><h4 id="①-RGB"><a href="#①-RGB" class="headerlink" title="① RGB"></a>① RGB</h4><p>Red/Green/Blue<br>红绿蓝，每个0~255，因此可以表示$256^3$种颜色<br><img src="/../images/post13_images/a33f3b2a71ca3653b8e46b2c37c0f1f4.png"></p>
<h4 id="②-HSV"><a href="#②-HSV" class="headerlink" title="② HSV"></a>② HSV</h4><p>Hue（色调）/Saturation（饱和度）/Value（亮度）<br><img src="/../images/post13_images/63295e8932a2054577fa6773825184f6.png"><br>Hue的取值是0°<del>360°；Saturation的取值是0</del>1；Value的取值是0~1<br>HSV在图像增强领域应用的比较多，能够更大程度保护图像颜色信息，避免色彩失真</p>
<h4 id="③-HLS"><a href="#③-HLS" class="headerlink" title="③ HLS"></a>③ HLS</h4><p>Hue（色调）/Lightness（亮度）/Saturation（饱和度）<br><img src="/../images/post13_images/81457c35c1609f9b35ecbd6030ebd880.png"><br>（图中说数值越大越小，色彩越白越黑，指的是）</p>
<h4 id="Value和Lightness的区别"><a href="#Value和Lightness的区别" class="headerlink" title="Value和Lightness的区别"></a>Value和Lightness的区别</h4><ul>
<li>Value：光线强度的明度</li>
<li>Lightness：白色光线的多少</li>
</ul>
<h2 id="4-图像直方图"><a href="#4-图像直方图" class="headerlink" title="4. 图像直方图"></a>4. 图像直方图</h2><h3 id="（1）构建直方图示例（简单灰度图像示例）"><a href="#（1）构建直方图示例（简单灰度图像示例）" class="headerlink" title="（1）构建直方图示例（简单灰度图像示例）"></a>（1）构建直方图示例（简单灰度图像示例）</h3><p>直方图Histograms，初始化直方图有i个格子（bin）：H[i]<br>假设i=4，对如下图的图像构建直方图：<br><img src="/../images/post13_images/f05d39f1037bb15116353a75b2431921.png"></p>
<h3 id="（2）归一化"><a href="#（2）归一化" class="headerlink" title="（2）归一化"></a>（2）归一化</h3><h4 id="①-动机"><a href="#①-动机" class="headerlink" title="① 动机"></a>① 动机</h4><p>对于两个大小不同的图像，想要进行比较，如果都选取同样bin的数量构建直方图，则小的图像显然取值少，无法合理比较。</p>
<h4 id="②-做法"><a href="#②-做法" class="headerlink" title="② 做法"></a>② 做法</h4><p>按照原来的取值，除以总像素数量即可。<br>在刚才的例子中，相当于从 $2,3 ,1,3$ 变成 $\frac{2}{9},\frac{3}{9},\frac{1}{9},\frac{3}{9}$</p>
<h3 id="（3）彩色图像构建直方图——颜色直方图"><a href="#（3）彩色图像构建直方图——颜色直方图" class="headerlink" title="（3）彩色图像构建直方图——颜色直方图"></a>（3）彩色图像构建直方图——颜色直方图</h3><h4 id="①-构建方法"><a href="#①-构建方法" class="headerlink" title="① 构建方法"></a>① 构建方法</h4><h5 id="a-方法1：分别构建三个通道的直方图"><a href="#a-方法1：分别构建三个通道的直方图" class="headerlink" title="a. 方法1：分别构建三个通道的直方图"></a>a. 方法1：分别构建三个通道的直方图</h5><h5 id="b-方法2：三个通道取均值-按比例得到一个数值，再构建一个直方图"><a href="#b-方法2：三个通道取均值-按比例得到一个数值，再构建一个直方图" class="headerlink" title="b. 方法2：三个通道取均值/按比例得到一个数值，再构建一个直方图"></a>b. 方法2：三个通道取均值/按比例得到一个数值，再构建一个直方图</h5><h4 id="②-颜色直方图的优点"><a href="#②-颜色直方图的优点" class="headerlink" title="② 颜色直方图的优点"></a>② 颜色直方图的优点</h4><ul>
<li>颜色直方图可以比较好的表示一张图像</li>
<li>计算过程快速且计算方式简单</li>
<li>可以将大小进行标准化，从而比较不同的图像直方图</li>
<li>可以利用颜色直方图进行数据库查询或分类</li>
</ul>
<h3 id="（4）总结bin与像素的关系"><a href="#（4）总结bin与像素的关系" class="headerlink" title="（4）总结bin与像素的关系"></a>（4）总结bin与像素的关系</h3><ul>
<li>每个像素都有且只有一个自己所属的bin</li>
<li>每个bin可能会对应多个像素</li>
</ul>
<h1 id="三、图像处理基础"><a href="#三、图像处理基础" class="headerlink" title="三、图像处理基础"></a>三、图像处理基础</h1><h2 id="1-噪声的去除"><a href="#1-噪声的去除" class="headerlink" title="1. 噪声的去除"></a>1. 噪声的去除</h2><p>如果能和周围的像素加权平均一下，噪声点的影响就变小了<br>因此可以把加权平均的权值做成一个卷积核/滤波核</p>
<h2 id="2-卷积"><a href="#2-卷积" class="headerlink" title="2. 卷积"></a>2. 卷积</h2><h3 id="（1）卷积核"><a href="#（1）卷积核" class="headerlink" title="（1）卷积核"></a>（1）卷积核</h3><h4 id="①-卷积核的意义"><a href="#①-卷积核的意义" class="headerlink" title="① 卷积核的意义"></a>① 卷积核的意义</h4><p>存储了当前点和周围点的加权平均的权值<br><img src="/../images/post13_images/568dc1194148738e2a082f16abb95060.png"><br>例如上图，$\frac{1}{9}$其实是需要乘到每个小方格里面的<br>那么以中间的$\frac{1}{9}$为例子，它就是由周围的$9$个$\frac{1}{9}$，加起来后除以$9$，进而得到的</p>
<h4 id="②-卷积的定义"><a href="#②-卷积的定义" class="headerlink" title="② 卷积的定义"></a>② 卷积的定义</h4><p>假设$f$是图像，$g$是卷积核：<br>$$(f * g)[m,n] = \sum_{k,l} f[m-k, n-l] g[k,l]$$<br>其中：<br>$m,n$是卷积模板最中间位置的坐标<br>$k,l$是翻转后卷积核的坐标，取值范围是$-1,0,1$<br>$g[k,l]$是翻转后的卷积核在(k,l)位置的值<br><strong>我认为需要结合一个例子来解释更清晰：</strong><br><img src="/../images/post13_images/14ea42f0ecee36dbc0b1126671110af8.png"><br><strong>关于卷积核的翻转：</strong><br>老师的PPT中翻转是垂直翻转，但实际上严格的卷积翻转是垂直+水平，也就是中心旋转180°<br>考试中如果提到翻转还是默认以老师PPT中的垂直翻转为准<br>上面的卷积公式，只有在中心旋转时才生效！否则不生效，是错误的！</p>
<h4 id="③-卷积的理解"><a href="#③-卷积的理解" class="headerlink" title="③ 卷积的理解"></a>③ 卷积的理解</h4><p><img src="/../images/post13_images/388e3a914032945e25299b0fead74271.png"><br>因此卷积做了翻转：<br><img src="/../images/post13_images/d03b2f7a5f086e2005bd71ba1f97fda1.png"></p>
<h3 id="（2）卷积操作的特性"><a href="#（2）卷积操作的特性" class="headerlink" title="（2）卷积操作的特性"></a>（2）卷积操作的特性</h3><h4 id="①-线性"><a href="#①-线性" class="headerlink" title="① 线性"></a>① 线性</h4><p>$$filter(f_1+f_2)=filter(f_1)+filter(f_2)$$<br>即$f_1,f_2$两张图像先求和在做卷积，等于分别卷积后在求和</p>
<h4 id="②-平移不变性"><a href="#②-平移不变性" class="headerlink" title="② 平移不变性"></a>② 平移不变性</h4><p>$$filter(shift(f))=shift(filter(f))$$<br>即一张图像先做平移还是先做卷积，结果是一样的<br><strong>推论：任何剪平移不变的操作，都可以用卷积来表示</strong></p>
<h4 id="③-一些数学特性"><a href="#③-一些数学特性" class="headerlink" title="③ 一些数学特性"></a>③ 一些数学特性</h4><ul>
<li>交换律：$a<em>b=b</em>a$</li>
<li>结合律：$a*(b<em>c)=(a</em>b)*c$</li>
<li>分配律：$a*(b+c)=(a<em>b)+(a</em>c)$</li>
<li>数乘结合律：$ka<em>b=a</em>kb=k(a*b)$</li>
<li>对于单位脉冲信号$e=[…,0,0,1,0,0,…]$，有$a*e=a$</li>
</ul>
<h3 id="（3）卷积核覆盖与图像大小的关系"><a href="#（3）卷积核覆盖与图像大小的关系" class="headerlink" title="（3）卷积核覆盖与图像大小的关系"></a>（3）卷积核覆盖与图像大小的关系</h3><p>matlab函数中通过指定shape，存在三种覆盖模式<br><img src="/../images/post13_images/95d591d05d9c3616f7dff8fc77150edb.png"></p>
<ul>
<li>full：卷积后图像会变大一圈</li>
<li>same：卷积后图像会保留原始尺寸</li>
<li>valid：卷积后图像会变小一圈</li>
</ul>
<h3 id="（4）卷积边缘填坑问腿"><a href="#（4）卷积边缘填坑问腿" class="headerlink" title="（4）卷积边缘填坑问腿"></a>（4）卷积边缘填坑问腿</h3><p>对于上面的same模式，由于卷积核部分在目标区域外，落在周围那一圈是我们需要填充的，有下面几个填充方法：</p>
<h4 id="①-Clip-filter（black）"><a href="#①-Clip-filter（black）" class="headerlink" title="① Clip filter（black）"></a>① Clip filter（black）</h4><p>就是常数填充<br>填充一圈黑的，会出现黑边，不太好<br>对应matlab：imfilter(f,g,0)</p>
<h4 id="②-wrap-around"><a href="#②-wrap-around" class="headerlink" title="② wrap around"></a>② wrap around</h4><p>填充的那一圈是从图像中随机采样的<br>对应matlab：imfilter(f,g,’circular’)</p>
<h4 id="③-copy-edge"><a href="#③-copy-edge" class="headerlink" title="③ copy edge"></a>③ copy edge</h4><p>填充的那一圈是把边缘继续延伸进去的<br>对应matlab：imfilter(f,g,’replicate’)</p>
<h4 id="④-reflect-across-edge"><a href="#④-reflect-across-edge" class="headerlink" title="④ reflect across edge"></a>④ reflect across edge</h4><p>填充的那一圈是沿着边缘镜像过去的<br>对应matlab：imfilter(f,g,’symme’)<br><img src="/../images/post13_images/62d3c1650c634c1796e1d32081151dd9.png"></p>
<h3 id="（5）常见卷积核"><a href="#（5）常见卷积核" class="headerlink" title="（5）常见卷积核"></a>（5）常见卷积核</h3><p><img src="/../images/post13_images/fc38dd0c2eceb75fb338638891a94b4b.png"><br><strong>锐化的原理：</strong><br>模糊/平滑卷积核相当于提取了平滑的特征，原图减去这些平滑的就剩不平滑的部分了，再加回原图相当于加强了。因此一共存在两倍的原图，所以在上面存在一个2<br><img src="/../images/post13_images/c0e3bdc8fc6f8acf17d178aa0a450182.png"><br>$$f*(2e-g)$$<br>同时，可以设置一个$α$在第二步加回去的突出部分前面，从而控制加回去多少细节，进而控制锐化强度，则有：<br>$$f + \alpha (f - f \ast g) = (1 + \alpha)f - \alpha f \ast g = f \ast ((1 + \alpha)e - \alpha g)$$</p>
<h3 id="（6）卷积核的有效性"><a href="#（6）卷积核的有效性" class="headerlink" title="（6）卷积核的有效性"></a>（6）卷积核的有效性</h3><h4 id="①-动机-1"><a href="#①-动机-1" class="headerlink" title="① 动机"></a>① 动机</h4><ul>
<li>卷积核通过与图像的像素值进行加权求和，提取特定的特征（如边缘、纹理）或实现滤波效果（如模糊、锐化）。卷积核中每个值的大小决定了对应位置像素的权重，因此可以说卷积核的设计直接影响了每个像素对输出结果的“贡献”。</li>
<li>想要得到更加有效的卷积模板，则应该考虑图像每个像素的贡献来设计卷积核的每个值，贡献大设计值大，贡献小设计值小。</li>
<li>因此很容易想到大部分情况下，中心像素对任务贡献最大。因此希望设计卷积核中间值大，越往两边越小。</li>
</ul>
<h3 id="②-高斯核-高斯滤波"><a href="#②-高斯核-高斯滤波" class="headerlink" title="② 高斯核/高斯滤波"></a>② 高斯核/高斯滤波</h3><p>$$G_\sigma = \frac{1}{2\pi\sigma^2} e^{-\frac{(x^2 + y^2)}{2\sigma^2}}$$<br>高斯函数就是中间大两头小，非常符合上面我们的想法。</p>
<h4 id="a-参数-sigma-（方差）"><a href="#a-参数-sigma-（方差）" class="headerlink" title="a. 参数$\sigma$（方差）"></a>a. 参数$\sigma$（方差）</h4><p>固定窗宽看方差变化的影响：</p>
<ul>
<li>$\sigma$越大，数据越分散，中心点峰值越小，卷积核中心值越小</li>
<li>$\sigma$越小，数据越集中，中心点峰值越大，卷积核中心值越大<br><img src="/../images/post13_images/9247199addd60a97673d778010320237.png"><br>因此$\sigma$可以控制平滑程度，形象点说，中心值越大说明对自己有很大的掌控权啊，平滑对我自己的影响就小，中心值小说明我容易丧失自我，就被平滑的很厉害~</li>
</ul>
<h4 id="b-窗宽"><a href="#b-窗宽" class="headerlink" title="b. 窗宽"></a>b. 窗宽</h4><p>固定方差看窗宽变化的影响：</p>
<ul>
<li>窗宽越小，在归一化时分母越小，每个的权重就越大，平滑程度越大</li>
<li>窗宽越大，在归一化时分母越大，每个的权重就越小，平滑程度越小<br><img src="/../images/post13_images/f4ba84297588a11164d00d332e4e1a23.png"></li>
</ul>
<h4 id="c-现实中如何设置"><a href="#c-现实中如何设置" class="headerlink" title="c. 现实中如何设置"></a>c. 现实中如何设置</h4><p>根据经验值，窗宽的一半=三倍的方差<br>一般在现成的工具包中，指定一个方差，窗宽会自动给出</p>
<h4 id="d-高斯核的特性"><a href="#d-高斯核的特性" class="headerlink" title="d. 高斯核的特性"></a>d. 高斯核的特性</h4><ul>
<li>作为低通滤波器，从图像中移除高频信号</li>
<li><font color="red"><strong>高斯核的自卷积是另一个高斯函数，因此可以用小粒度高斯核的多次卷积，得到使用大粒度高斯核卷积相同的结果。    【重要！】</strong></font><br>![](../images/post13_images/ /8fab1ebe7bf74472049b9536fa518edd.png)<br>图中的 $I$ 表示图像；同时这里符合勾股定理，$a^2+b^2=c^2$</li>
<li>一个二维的高斯函数可以拆分成两个一维的——<strong>可分离的</strong>函数<br>可分离性的应用：<br><img src="/../images/post13_images/624eb31b695986113315cc50e03817ca.png"><br>就是一个拆分后逐步计算</li>
</ul>
<h3 id="（7）卷积的时间复杂度"><a href="#（7）卷积的时间复杂度" class="headerlink" title="（7）卷积的时间复杂度"></a>（7）卷积的时间复杂度</h3><p>$m×m$ 的卷积核 和 $n×n$ 的图像做卷积</p>
<h4 id="①-一般情况"><a href="#①-一般情况" class="headerlink" title="① 一般情况"></a>① 一般情况</h4><p>$O(n^2m^2)$</p>
<h4 id="②-卷积核可分离的情况"><a href="#②-卷积核可分离的情况" class="headerlink" title="② 卷积核可分离的情况"></a>② 卷积核可分离的情况</h4><p>$O(n^2m)$</p>
<h2 id="3-噪声"><a href="#3-噪声" class="headerlink" title="3. 噪声"></a>3. 噪声</h2><h3 id="（1）噪声的种类"><a href="#（1）噪声的种类" class="headerlink" title="（1）噪声的种类"></a>（1）噪声的种类</h3><p><img src="/../images/post13_images/e991f67613e75b26e3acf7f170039324.png"></p>
<h4 id="①-椒盐噪声（Salt-and-pepper-noise）"><a href="#①-椒盐噪声（Salt-and-pepper-noise）" class="headerlink" title="① 椒盐噪声（Salt and pepper noise）"></a>① 椒盐噪声（Salt and pepper noise）</h4><blockquote>
<p>像随机在图像上撒了一把“椒盐”，有黑的有白的</p>
</blockquote>
<p>随机出现黑白像素</p>
<h4 id="②-白噪声（Impulse-noise）"><a href="#②-白噪声（Impulse-noise）" class="headerlink" title="② 白噪声（Impulse noise）"></a>② 白噪声（Impulse noise）</h4><p>随机出现白色像素</p>
<h4 id="③-高斯噪声（Gaussian-noise）"><a href="#③-高斯噪声（Gaussian-noise）" class="headerlink" title="③ 高斯噪声（Gaussian noise）"></a>③ 高斯噪声（Gaussian noise）</h4><p>出现从高斯正态分布得到的强度变化（叠加变量）<br>$$f(x, y) = \hat{f}(x, y) + \eta(x, y)$$<br>其中：</p>
<ul>
<li>$f(x, y)$ 是高斯噪声产生后的图像</li>
<li>$\hat{f}(x, y)$ 是理想状态没有高斯噪声的清晰图像</li>
<li>$\eta(x, y)$ 是高斯噪声，满足$\eta(x, y)$~$N(μ,σ)$ ，即服从高斯分布</li>
</ul>
<h3 id="（2）使用高斯滤波器去除高斯噪声"><a href="#（2）使用高斯滤波器去除高斯噪声" class="headerlink" title="（2）使用高斯滤波器去除高斯噪声"></a>（2）使用高斯滤波器去除高斯噪声</h3><p><img src="/../images/post13_images/0fe237f3052110aab6472db0f277e7bf.png"><br>但上图也可以发现，大方差高斯卷积核虽然更能去除噪声，但也<strong>损失图像细节</strong></p>
<h3 id="（3）去除椒盐噪声"><a href="#（3）去除椒盐噪声" class="headerlink" title="（3）去除椒盐噪声"></a>（3）去除椒盐噪声</h3><h4 id="①-高斯卷积核效果不佳"><a href="#①-高斯卷积核效果不佳" class="headerlink" title="① 高斯卷积核效果不佳"></a>① 高斯卷积核效果不佳</h4><p>用高斯卷积核去除椒盐噪声<strong>效果不理想</strong>：<br><img src="/../images/post13_images/16fb090613a3e2bbbb402e1384823f38.png"><br>大模板不仅没能更有效去除噪声，反而还损失了不少图像细节</p>
<h4 id="②-中值滤波的步骤"><a href="#②-中值滤波的步骤" class="headerlink" title="② 中值滤波的步骤"></a>② 中值滤波的步骤</h4><h5 id="a-第一步：生成模板（3×3为例）"><a href="#a-第一步：生成模板（3×3为例）" class="headerlink" title="a. 第一步：生成模板（3×3为例）"></a>a. 第一步：生成模板（3×3为例）</h5><p>单纯一个3×3的框，里面啥也没有</p>
<h5 id="b-第二步：放到图像中取出像素值"><a href="#b-第二步：放到图像中取出像素值" class="headerlink" title="b. 第二步：放到图像中取出像素值"></a>b. 第二步：放到图像中取出像素值</h5><h5 id="c-第三步：对其中的值找到中位数"><a href="#c-第三步：对其中的值找到中位数" class="headerlink" title="c. 第三步：对其中的值找到中位数"></a>c. 第三步：对其中的值找到中位数</h5><p><img src="/../images/post13_images/a5257af2a6160a141995951348c110d9.png"></p>
<h5 id="d-第四步：用中位数替代模板最中间的值"><a href="#d-第四步：用中位数替代模板最中间的值" class="headerlink" title="d. 第四步：用中位数替代模板最中间的值"></a>d. 第四步：用中位数替代模板最中间的值</h5><blockquote>
<p>Q：中值滤波是一个线性操作嘛？<br>A：不是，因为其中核心原理在排序，排序不是线性操作。</p>
</blockquote>
<h4 id="③-中值滤波的优点"><a href="#③-中值滤波的优点" class="headerlink" title="③ 中值滤波的优点"></a>③ 中值滤波的优点</h4><h5 id="a-擅长处理椒盐噪声、白噪声"><a href="#a-擅长处理椒盐噪声、白噪声" class="headerlink" title="a. 擅长处理椒盐噪声、白噪声"></a>a. 擅长处理椒盐噪声、白噪声</h5><h5 id="b-和均值滤波相比"><a href="#b-和均值滤波相比" class="headerlink" title="b. 和均值滤波相比"></a>b. 和均值滤波相比</h5><p><img src="/../images/post13_images/d8d32d9613174203f86ed491eacc5e2c.png"></p>
<h1 id="四、边缘检测"><a href="#四、边缘检测" class="headerlink" title="四、边缘检测"></a>四、边缘检测</h1><h2 id="1-边缘基本概念"><a href="#1-边缘基本概念" class="headerlink" title="1. 边缘基本概念"></a>1. 边缘基本概念</h2><h3 id="（1）边缘的定义"><a href="#（1）边缘的定义" class="headerlink" title="（1）边缘的定义"></a>（1）边缘的定义</h3><p>图像中亮度值明显而急剧变化的点</p>
<h3 id="（2）研究边缘的意义"><a href="#（2）研究边缘的意义" class="headerlink" title="（2）研究边缘的意义"></a>（2）研究边缘的意义</h3><ul>
<li>图像中大多数语义和形状信息可在边缘进行编码</li>
<li>相对于像素表示边缘表示更加紧凑<br>图像→边缘→语义</li>
</ul>
<h3 id="（3）边缘的分类"><a href="#（3）边缘的分类" class="headerlink" title="（3）边缘的分类"></a>（3）边缘的分类</h3><ul>
<li>表面法向不连续</li>
<li>深度不连续</li>
<li>表面颜色不连续</li>
<li>光照不连续<br><img src="/../images/post13_images/79e912ac1a3c00f556e77546261682a9.png"></li>
</ul>
<h2 id="2-边缘的提取"><a href="#2-边缘的提取" class="headerlink" title="2. 边缘的提取"></a>2. 边缘的提取</h2><h3 id="（1）思路"><a href="#（1）思路" class="headerlink" title="（1）思路"></a>（1）思路</h3><p>水平方向观察到像素值变化，强度函数求导找到极值点,极值点展示出边缘<br><img src="/../images/post13_images/e914eceb58b435ebfeee3474855e0467.png"></p>
<h3 id="（2）图像求导"><a href="#（2）图像求导" class="headerlink" title="（2）图像求导"></a>（2）图像求导</h3><h4 id="①-2D函数求导公式"><a href="#①-2D函数求导公式" class="headerlink" title="① 2D函数求导公式"></a>① 2D函数求导公式</h4><p>$$\frac{\partial f(x, y)}{\partial x} = \lim_{\varepsilon \to 0} \frac{f(x + \varepsilon, y) - f(x, y)}{\varepsilon}$$</p>
<h4 id="②-图像求导公式"><a href="#②-图像求导公式" class="headerlink" title="② 图像求导公式"></a>② 图像求导公式</h4><p>图像是一个一个像素，是离散存储的，并不是上面那样连续的，因此只能取$\epsilon=1$来近似：<br>$$\frac{\partial f(x, y)}{\partial x} \approx \frac{f(x + 1, y) - f(x, y)}{1}$$<br>相当于右边的像素减去自己，就是导数了</p>
<h4 id="③-用卷积实现图像求导"><a href="#③-用卷积实现图像求导" class="headerlink" title="③ 用卷积实现图像求导"></a>③ 用卷积实现图像求导</h4><p>如图设计卷积核：<br><img src="/../images/post13_images/6572a796ec866d8e5d5d9dc78238fe75.png"><br>正好水平x求导就是右减左，竖直y求导就是下减上</p>
<h4 id="④-解释对不同方向求导得出垂直方向特征图像的原因【导数模板方向和信号方向是垂直关系】"><a href="#④-解释对不同方向求导得出垂直方向特征图像的原因【导数模板方向和信号方向是垂直关系】" class="headerlink" title="④ 解释对不同方向求导得出垂直方向特征图像的原因【导数模板方向和信号方向是垂直关系】"></a>④ 解释对不同方向求导得出垂直方向特征图像的原因【导数模板方向和信号方向是垂直关系】</h4><p><img src="/../images/post13_images/df18927abab0b64a37451286e6552fef.png"><br>解释：<br>对于x方向，求导相当于水平两个像素做差。</p>
<ul>
<li>如果水平的两个像素差异不大，相减就相当于0，什么都没有了，导数为接近0，而前面说了，求导数后导数的极值点展示了边缘，所以没有展示出x方向的边缘。</li>
<li>如果水平的两个像素差异明显，同理，那么导数就得到了极值点，检测出y方向边缘。<br><img src="/../images/post13_images/1737439c8fe7834b23afa913bcee0064.png"></li>
</ul>
<h4 id="⑤-其他常见的导数滤波器（可略）"><a href="#⑤-其他常见的导数滤波器（可略）" class="headerlink" title="⑤ 其他常见的导数滤波器（可略）"></a>⑤ 其他常见的导数滤波器（可略）</h4><h5 id="a-简介"><a href="#a-简介" class="headerlink" title="a. 简介"></a>a. 简介</h5><p><img src="/../images/post13_images/65375152be328c5234f7125884569718.png"></p>
<ul>
<li>Prewitt：利用像素点上下、左右邻点的灰度差。这种判定是欠合理的，会造成边缘点的误判，因为许多噪声点的灰度值也很大，而且对于幅值较小的边缘点，其边缘反而丢失了。</li>
<li>Sobel：Sobel 算子在 Prewitt 算子的基础上增加了权重的概念，认为相邻点的距离远近对当前像素点的影响是不同的，距离越近的像素点对应当前像素的影响越大，从而实现图像锐化并突出边缘轮廓。</li>
<li>Roberts：交叉算子边缘检测方法。该方法最大优点是计算量小，速度快。但该方法由于是采用偶数模板，如下图所示，所求的(x,y)点处梯度幅度值，其实是图中交叉点处的值，从而导致在图像(x,y)点所求的梯度幅度值偏移了半个像素<br><img src="/../images/post13_images/eb7ca1698d2d9d3e6c8711df862ff915.png"></li>
</ul>
<h5 id="b-总结"><a href="#b-总结" class="headerlink" title="b. 总结"></a>b. 总结</h5><ul>
<li>Robert算子对陡峭的低噪声图像效果较好，尤其是边缘正负45度较多的图像，但定位准确率较差；</li>
<li>Prewitt算子对灰度渐变的图像边缘提取效果较好，而没有考虑相邻点的距离远近对当前像素点的影响；</li>
<li>Sobel算子考虑了综合因素，对噪声较多的图像处理效果更好。<br><img src="/../images/post13_images/ac18a383e7c30fcc5fbd95d400953594.png"></li>
</ul>
<h3 id="（3）图像梯度"><a href="#（3）图像梯度" class="headerlink" title="（3）图像梯度"></a>（3）图像梯度</h3><p><img src="/../images/post13_images/2b94b200b979f35581cd0088d4e151cc.png"></p>
<h2 id="3-噪声对边缘的影响"><a href="#3-噪声对边缘的影响" class="headerlink" title="3. 噪声对边缘的影响"></a>3. 噪声对边缘的影响</h2><h3 id="（1）影响"><a href="#（1）影响" class="headerlink" title="（1）影响"></a>（1）影响</h3><p>存在影响：<br><img src="/../images/post13_images/acd89619e493294306a1eab8978d5bf2.png"></p>
<h3 id="（2）原因"><a href="#（2）原因" class="headerlink" title="（2）原因"></a>（2）原因</h3><p><img src="/../images/post13_images/cbe2af545dc0f863efb03fd44e18065d.png"><br>由于噪声的存在，找不到极值点了</p>
<h3 id="（3）解决"><a href="#（3）解决" class="headerlink" title="（3）解决"></a>（3）解决</h3><h4 id="①-流程"><a href="#①-流程" class="headerlink" title="① 流程"></a>① 流程</h4><p>先去噪，再对信号求导，找到极值点<br><img src="/../images/post13_images/c44f26b9647acdf319383576ed77e1c4.png"></p>
<h4 id="②-弊端"><a href="#②-弊端" class="headerlink" title="② 弊端"></a>② 弊端</h4><p>存在两次卷积，一次是去噪时卷积（$f<em>g$），另一次是求偏导时用导数模板做卷积求出偏导数，即上图红框的部分的求导过程。<br>当图像数量多的时候，由于存在两次卷积，*<em>计算量大</em></em></p>
<h4 id="③-弊端的进一步解决"><a href="#③-弊端的进一步解决" class="headerlink" title="③ 弊端的进一步解决"></a>③ 弊端的进一步解决</h4><p>利用卷积的结合性：$\frac{d}{dx}(f * g) = f * \frac{d}{dx}g$<br>也就是：</p>
<ul>
<li>先对高斯核进行求导——得到 <font color="red"><strong>高斯一阶偏导核</strong></font></li>
<li>再利用求导后的高斯核来和原始的有噪声的图像做卷积<br><img src="/../images/post13_images/cfb1ae26fc3bf2c26ae1a7775a9db82b.png"></li>
</ul>
<h4 id="④-高斯一阶偏导核"><a href="#④-高斯一阶偏导核" class="headerlink" title="④ 高斯一阶偏导核"></a>④ 高斯一阶偏导核</h4><h5 id="a-可视化"><a href="#a-可视化" class="headerlink" title="a. 可视化"></a>a. 可视化</h5><p>看一下就行：<br><img src="/../images/post13_images/8b49e7eb0501dc0bdd18435f85d255b2.png"></p>
<h5 id="b-方差的影响"><a href="#b-方差的影响" class="headerlink" title="b. 方差的影响"></a>b. 方差的影响</h5><p>随高斯一阶偏导核方差变大，图像细节的丢失也会越来越严重</p>
<blockquote>
<p>实际应用中，如果要识别细微的边缘特征，肯定方差设置小一点会好些；但如果只是想粗糙识别一下，比如看远方的一个物体是不是人，那方差设置大一点会好些，保留了轮廓信息<br>【就是看我们需要的轮廓是粗糙的还是细微的】</p>
</blockquote>
<h5 id="c-可分离性证明"><a href="#c-可分离性证明" class="headerlink" title="c. 可分离性证明"></a>c. 可分离性证明</h5><p><img src="/../images/post13_images/fa68aa6e8847a0a41ab9a8c7cc24cdb4.png"></p>
<h5 id="d-高斯核-vs-高斯一阶偏导核"><a href="#d-高斯核-vs-高斯一阶偏导核" class="headerlink" title="d. 高斯核 vs 高斯一阶偏导核"></a>d. 高斯核 vs 高斯一阶偏导核</h5><p>总结对比一下：<br><img src="/../images/post13_images/35ce0e86b652578d02f876c32b2cbf13.png"></p>
<h2 id="4-Canny边缘检测器"><a href="#4-Canny边缘检测器" class="headerlink" title="4. Canny边缘检测器"></a>4. Canny边缘检测器</h2><blockquote>
<p>这部分智慧课堂无声，本人参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42118657/article/details/121255328">CS131专题-3：图像梯度、边缘检测（sobel、canny等）</a>进行学习，感谢这篇博客。这篇博客恰好对应本章所有内容，相较课内更为详细，推荐学习。</p>
</blockquote>
<h3 id="（1）提出动机"><a href="#（1）提出动机" class="headerlink" title="（1）提出动机"></a>（1）提出动机</h3><p>常规边缘检测算法存在以下问题：</p>
<ul>
<li>边缘很粗：如sobel这样的边缘检测算子，对图像求梯度图后，会设置一个阈值，绝对值超过阈值的像素为视为边缘，这就导致得到的边缘图中“边缘”会很粗<br><img src="/../images/post13_images/08e2185d3cd2fe3a0f0481b1b8bd8592.png"></li>
<li>渐变边低于阈值，无法被识别为边缘：由于sobel中梯度阈值是全局性的，不能太高也不能太低，这就导致很多不明显的渐变边被擦除。<br><img src="/../images/post13_images/36f9d48a22cde65528e3c8269167be76.png"></li>
</ul>
<h3 id="（2）Canny边缘检测器算法流程"><a href="#（2）Canny边缘检测器算法流程" class="headerlink" title="（2）Canny边缘检测器算法流程"></a>（2）Canny边缘检测器算法流程</h3><p>matlab：edge(image,’canny’)</p>
<h4 id="①-对原始图像进行灰度化"><a href="#①-对原始图像进行灰度化" class="headerlink" title="① 对原始图像进行灰度化"></a>① 对原始图像进行灰度化</h4><p>此步课内PPT未提及，但是要进行的。因为边缘检测本质检测的是亮度变化。</p>
<h4 id="②-对图像进行平滑（高斯滤波）"><a href="#②-对图像进行平滑（高斯滤波）" class="headerlink" title="② 对图像进行平滑（高斯滤波）"></a>② 对图像进行平滑（高斯滤波）</h4><p>用高斯导数对图像进行滤波：对图像的x方向和y方向求梯度</p>
<h4 id="③-求图像平滑后的梯度图、以及梯度方向图"><a href="#③-求图像平滑后的梯度图、以及梯度方向图" class="headerlink" title="③ 求图像平滑后的梯度图、以及梯度方向图"></a>③ 求图像平滑后的梯度图、以及梯度方向图</h4><p>计算梯度强度（衡量是否为边缘）和梯度方向（用于非极大值抑制）</p>
<h4 id="④-NMS非极大值抑制筛选"><a href="#④-NMS非极大值抑制筛选" class="headerlink" title="④ NMS非极大值抑制筛选"></a>④ NMS非极大值抑制筛选</h4><p>顾名思义就是在附近的一堆值中找到最大的那个，然后把不是最大的都设0<br><img src="/../images/post13_images/21c5b2245b44a323e4d37f36f74559c1.png"><br>对比一下非极大值抑制的效果，明显变细了：<br><img src="/../images/post13_images/7c66d41c3bbadfe147ef53b64c9ca5fd.png"></p>
<h4 id="⑤-双阈值-连通与否筛选"><a href="#⑤-双阈值-连通与否筛选" class="headerlink" title="⑤ 双阈值+连通与否筛选"></a>⑤ 双阈值+连通与否筛选</h4><p>双门限法：定义两个阈值</p>
<ul>
<li>高阈值：检测强边缘</li>
<li>低阈值：连接强边缘<br><img src="/../images/post13_images/51bf3feebbd7360d9977231cade81e4e.png"><br>简单来说就是高于高的就是边缘，低于低的就不是边缘，在中间的看有没有穿过高阈值的部分</li>
</ul>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul>
<li>在②③两部分，实际中会采取之前说的先得到高斯一阶偏导核，再做卷积~</li>
<li>高斯核的方差$\sigma$越大，对图像平滑效果越强，越容易把边缘平滑掉，边缘会稀疏（仅保留非常明显的边缘）；反之，边缘会密集、详细。因此可控制方差大小获得想要的边缘图。</li>
<li>Canny边缘检测的一些缺点：边缘可能不连续、边缘位置可能出现空间偏移（偏离真实边界）、方差的变化会明显改变结果，鲁棒性差。<br><img src="/../images/post13_images/9621d8a62d6e10bd05ccb16856a1c0f9.png"></li>
</ul>
<h2 id="5-其他边缘检测技术（缺）"><a href="#5-其他边缘检测技术（缺）" class="headerlink" title="5. 其他边缘检测技术（缺）"></a>5. 其他边缘检测技术（缺）</h2><blockquote>
<p>因为视频没声，PPT这部分也看不出来是想说啥细节，所以只能略过喽</p>
</blockquote>
<ul>
<li>CNN 边缘检测模型</li>
<li>用Transformer做边缘检测</li>
<li>语义边缘检测</li>
<li>遮挡边缘检测</li>
</ul>
<h1 id="五、拟合（Fitting）"><a href="#五、拟合（Fitting）" class="headerlink" title="五、拟合（Fitting）"></a>五、拟合（Fitting）</h1><blockquote>
<p>边缘检测出的边缘是一个底层的特征 low-level<br><strong>从边缘图中，通过拟合技术，进一步提取需要的几何边缘</strong></p>
</blockquote>
<h2 id="1-拟合的基本概念"><a href="#1-拟合的基本概念" class="headerlink" title="1. 拟合的基本概念"></a>1. 拟合的基本概念</h2><h3 id="（1）目标"><a href="#（1）目标" class="headerlink" title="（1）目标"></a>（1）目标</h3><p>找到一个参数化的模型，来表示特征</p>
<h3 id="（2）难点-需要解决的问题"><a href="#（2）难点-需要解决的问题" class="headerlink" title="（2）难点/需要解决的问题"></a>（2）难点/需要解决的问题</h3><p><img src="/../images/post13_images/b747884957bd4465dc44a6d937e56064.png"></p>
<ul>
<li>噪声：图像以及预处理会存在各种噪声，影响拟合</li>
<li>外点/无关点：比如我只想找车上的几何形状，那么车之外的像素点都是无关点，这些点会影响程序自动化寻找车的形状</li>
<li>缺失数据——遮挡：由于遮挡关系，几何形状可能是间断的。比如想检测车后面房子的窗户的形状，结果由于车在前面，被挡住了。</li>
</ul>
<h2 id="2-拟合的常见方法"><a href="#2-拟合的常见方法" class="headerlink" title="2. 拟合的常见方法"></a>2. 拟合的常见方法</h2><h3 id="（1）最小二乘法（Least-squres-line-fitting）"><a href="#（1）最小二乘法（Least-squres-line-fitting）" class="headerlink" title="（1）最小二乘法（Least squres line fitting）"></a>（1）最小二乘法（Least squres line fitting）</h3><h4 id="①-原理"><a href="#①-原理" class="headerlink" title="① 原理"></a>① 原理</h4><h5 id="a-确定目标函数"><a href="#a-确定目标函数" class="headerlink" title="a. 确定目标函数"></a>a. 确定目标函数</h5><p><img src="/../images/post13_images/8a0b4e595d6d4a8e4c73235739c1ba8b.png"></p>
<h5 id="b-最小化目标函数"><a href="#b-最小化目标函数" class="headerlink" title="b. 最小化目标函数"></a>b. 最小化目标函数</h5><p>利用$|\mathbf{P}|^2 = P_1^2 + P_2^2 + \cdots + P_n^2=\mathbf{P}^T\mathbf{P}$<br><img src="/../images/post13_images/7f0ccb8dc1b03b50228562fab8271ed3.png"><br>最终得到了最优直线对应的m和b（B矩阵）</p>
<h4 id="②-缺陷"><a href="#②-缺陷" class="headerlink" title="② 缺陷"></a>② 缺陷</h4><p><img src="/../images/post13_images/29550c26cb37aba9aecf8f0973a3ee93.png"><br>所以缺陷就是没办法解决垂直线，因为它不是旋转不变的，只要发生旋转了，就解决不好问题了</p>
<h3 id="（2）全最小二乘法（Total-least-squares）"><a href="#（2）全最小二乘法（Total-least-squares）" class="headerlink" title="（2）全最小二乘法（Total least squares）"></a>（2）全最小二乘法（Total least squares）</h3><h4 id="①-原理-1"><a href="#①-原理-1" class="headerlink" title="① 原理"></a>① 原理</h4><p>本质上就是将计算的距离从竖直方向距离改为点到直线的距离<br>最优化的参数从两个（m，b）变为三个（a，b，d）<br><img src="/../images/post13_images/8e61f7f2d99b3bc1a05ade96d02e46fa.png"><br><img src="/../images/post13_images/bfafdc9629a990839758aa3ee221d0fa.png"><br>其中从对d求导到得到d的a、b表示：<br>$$\sum_{i=1}^{n} (-2ax_i - 2by_i + 2d) = 0$$<br>$$d=\sum_{i=1}^{n}(ax_i+by_i)$$<br>$$d = \frac{a}{n} \sum_{i=1}^{n} x_i + \frac{b}{n} \sum_{i=1}^{n} y_i = a \bar{x} + b \bar{y}$$<br>以及其中矩阵U：<br><img src="/../images/post13_images/1dbdcf11de1c89a201662a0f212000bc.png"></p>
<h4 id="②-优缺点"><a href="#②-优缺点" class="headerlink" title="② 优缺点"></a>② 优缺点</h4><ul>
<li>优点：相较于最小二乘，具有旋转不变性</li>
<li>缺点：不能很好地对抗噪声点<br><img src="/../images/post13_images/b1da2f3b0ccee2fdec55f5054d6107b6.png"></li>
</ul>
<h4 id="③-从概率角度理解全最小二乘"><a href="#③-从概率角度理解全最小二乘" class="headerlink" title="③ 从概率角度理解全最小二乘"></a>③ 从概率角度理解全最小二乘</h4><blockquote>
<p>感觉不是很重要，但是PPT讲了，就附带一下吧<br>也就是最小二乘法与极大似然估计之间的内在联系</p>
</blockquote>
<p><strong>假设：</strong><br>存在一条理想直线（最终的拟合直线）$ax+by=d$，法向量$\mathbf{n}=(a,b)$，直线上真实点坐标为$(u,v)$，但观测点$(x,y)$受到垂直于直线方向的噪声干扰。<br><strong>观测点的表示：</strong><br>$$(x, y) = (u, v) + \varepsilon \cdot \frac{(a, b)}{\sqrt{a^2 + b^2}}$$<br>其中$ε$是噪声幅值，服从均值为0、标准差为$σ$的高斯分布<br><strong>单点概率密度：</strong><br>给定直线参数 $(a,b,d)$，观测点$(x_i,y_i)$的噪声服从高斯分布，由于理想点$(u,v)$满足$au+bv=d$，垂直距离$\varepsilon = \frac{|ax_i + by_i - d|}{\sqrt{a^2 + b^2}}$，结合高斯分布公式，化简得到观测点$(x_i,y_i)$的概率密度为：<br>$$P(x_i, y_i \mid a, b, d) \propto \exp \left( -\frac{(ax_i + by_i - d)^2}{2\sigma^2} \right)$$<br><strong>似然函数：</strong><br>假设所有观测点独立同分布，联合似然函数为各点概率的乘积：<br>$$\mathcal{L}(a, b, d) = \prod_{i=1}^{n} \exp \left( -\frac{(ax_i + by_i - d)^2}{2\sigma^2} \right)$$<br><strong>对数似然函数：</strong><br>$$\ln \mathcal{L}(a, b, d) = -\frac{1}{2\sigma^2} \sum_{i=1}^{n} (ax_i + by_i - d)^2$$<br><strong>最大化似然函数相当于：</strong><br>$$\max_{a,b,d} -\sum_{i=1}^{n} (ax_i + by_i - d)^2$$<br><strong>等价于全最小二乘的目标：</strong><br>$$\min_{a,b,d} \sum_{i=1}^{n} (ax_i + by_i - d)^2$$</p>
<h3 id="（3）鲁棒最小二乘法"><a href="#（3）鲁棒最小二乘法" class="headerlink" title="（3）鲁棒最小二乘法"></a>（3）鲁棒最小二乘法</h3><h4 id="①-原理-2"><a href="#①-原理-2" class="headerlink" title="① 原理"></a>① 原理</h4><p>根据点的残差来差异化特征贡献，也就是离得近的贡献大，离得远的贡献小<br><strong>找到最优参数 $\theta$ 最小化目标损失函数：</strong><br>$$\sum_{i} \rho(r_i(x_i, \theta); \sigma)=\sum_{i} \rho(u;\sigma)=\sum_{i} \frac{u^2}{\sigma^2+u^2}$$<br>其中：</p>
<ul>
<li>$u=r_i(x_i,θ)$是第 $i$ 个数据点的残差（模型预测值与真实值的偏差）</li>
<li>$σ$ 是尺度参数，控制函数从“类平方”到“饱和”的转折点。$σ$  越小，函数越早进入饱和区，模型对离群点更鲁棒；$σ$  越大，饱和区延迟，模型更接近传统最小二乘。<br><img src="/../images/post13_images/1f420d0acb628860ab3da05239d329c4.png"><br>如上图，横坐标是残差 $u$ ，纵坐标是对应的响应（贡献）$\rho$，三条曲线分别展现了不同 $σ$ 大小带来的影响。</li>
</ul>
<h4 id="②-特点"><a href="#②-特点" class="headerlink" title="② 特点"></a>② 特点</h4><ul>
<li>非线性优化过程，经过了一个非线性的变换</li>
<li>可以先用全最小二乘初始化初始解，再用梯度下降方法取求最优解</li>
<li>受 $\sigma$ 大小的影响很大，一般选择1.5倍的平均残差</li>
</ul>
<h4 id="③-优缺点"><a href="#③-优缺点" class="headerlink" title="③ 优缺点"></a>③ 优缺点</h4><ul>
<li>优点：对外点具有鲁棒性</li>
<li>缺点：依赖于 $σ$ 的取值，取大取小都不好；如果外点数变多，表现可能也不是那么好了<br><img src="/../images/post13_images/c921a13f321cab84bb954899c455f683.png"></li>
</ul>
<h3 id="（4）随机采样一致性算法RANSAC"><a href="#（4）随机采样一致性算法RANSAC" class="headerlink" title="（4）随机采样一致性算法RANSAC"></a>（4）随机采样一致性算法RANSAC</h3><blockquote>
<p>如果有很多外点，鲁棒最小二乘可能也不好用了<br>RANSAC：Random sample consensus</p>
</blockquote>
<h4 id="①-原理流程（以直线为例）"><a href="#①-原理流程（以直线为例）" class="headerlink" title="① 原理流程（以直线为例）"></a>① 原理流程（以直线为例）</h4><h5 id="a-随机从所有点中选择所需的最少的样本点（如估计一条直线方程需要两个点，其他模型可能不一样）"><a href="#a-随机从所有点中选择所需的最少的样本点（如估计一条直线方程需要两个点，其他模型可能不一样）" class="headerlink" title="a. 随机从所有点中选择所需的最少的样本点（如估计一条直线方程需要两个点，其他模型可能不一样）"></a>a. 随机从所有点中选择所需的最少的样本点（如估计一条直线方程需要两个点，其他模型可能不一样）</h5><h5 id="b-拟合出一条直线"><a href="#b-拟合出一条直线" class="headerlink" title="b. 拟合出一条直线"></a>b. 拟合出一条直线</h5><h5 id="c-计算每个点到该直线的距离，并设置一个距离的阈值-门限"><a href="#c-计算每个点到该直线的距离，并设置一个距离的阈值-门限" class="headerlink" title="c. 计算每个点到该直线的距离，并设置一个距离的阈值/门限"></a>c. 计算每个点到该直线的距离，并设置一个距离的阈值/门限</h5><h5 id="d-记录落在阈值-门限范围内的点的数量（内点数量），作为投票得分"><a href="#d-记录落在阈值-门限范围内的点的数量（内点数量），作为投票得分" class="headerlink" title="d. 记录落在阈值/门限范围内的点的数量（内点数量），作为投票得分"></a>d. 记录落在阈值/门限范围内的点的数量（内点数量），作为投票得分</h5><h5 id="e-重复abcd这四步若干次"><a href="#e-重复abcd这四步若干次" class="headerlink" title="e. 重复abcd这四步若干次"></a>e. 重复abcd这四步若干次</h5><h5 id="f-跳出迭代后，选用内点最多（投票得分最高）的拟合结果"><a href="#f-跳出迭代后，选用内点最多（投票得分最高）的拟合结果" class="headerlink" title="f. 跳出迭代后，选用内点最多（投票得分最高）的拟合结果"></a>f. 跳出迭代后，选用内点最多（投票得分最高）的拟合结果</h5><p><img src="/../images/post13_images/1d04e12fa76de326f80a0f8c6c106bfc.png"></p>
<h4 id="②-参数设置"><a href="#②-参数设置" class="headerlink" title="② 参数设置"></a>② 参数设置</h4><h5 id="a-初始化样本点数-s"><a href="#a-初始化样本点数-s" class="headerlink" title="a. 初始化样本点数 s"></a>a. 初始化样本点数 s</h5><p>这个是跟任务相关的，直线最少需要俩点，其他模型可能更多</p>
<h5 id="b-门限-阈值-t"><a href="#b-门限-阈值-t" class="headerlink" title="b. 门限/阈值 t"></a>b. 门限/阈值 t</h5><h5 id="c-迭代次数-N"><a href="#c-迭代次数-N" class="headerlink" title="c. 迭代次数 N"></a>c. 迭代次数 N</h5><blockquote>
<p>迭代多少次才结束呢？需要选取一个合适的迭代次数</p>
</blockquote>
<h6 id="i-基本原理"><a href="#i-基本原理" class="headerlink" title="i. 基本原理"></a>i. 基本原理</h6><p>先设置两个概率：</p>
<ul>
<li><strong>最优概率 $p$：</strong> 只要这个拟合结果有 $p$ 的概率能够准确检测所有样本点的，那么久接受它，不去继续找了</li>
<li><strong>外点概率 $e$：</strong> 某个点不属于拟合结果的概率是 $e$</li>
</ul>
<p>然后进行下面的理解：</p>
<ul>
<li>最终拟合直线的准确率是 $p$</li>
<li>最终拟合直线预测错误的概率是 $1-p$</li>
<li>外点的概率是 $e$</li>
<li>内点的概率是 $1-e$</li>
<li>对于某一次迭代，最开始选了 $s$ 个点做初始化，内点的概率是 $(1-e)^s$</li>
<li>对于某一次迭代，最开始选了 $s$ 个点做初始化，外点的概率是 $1-(1-e)^s$</li>
<li>对于总共 $N$ 次迭代，外点的概率是 $(1-(1-e)^s)^N$</li>
</ul>
<p>对于理想的拟合直线，它已经是由很多内点投票出来的直线了，它对于这些内点，就相当于是可以预测/检测成功的；那相对应的，如果遇到外点了，那可不就是会预测错误嘛<br>所以：<br>$$1-(1-e)^s=1-p$$<br>满足上式的 $N$ 就是我们想要的，反解出来：<br>$$N=log(1-p)/log(1-(1-e)^s)$$ </p>
<h6 id="ii-自适应算法"><a href="#ii-自适应算法" class="headerlink" title="ii. 自适应算法"></a>ii. 自适应算法</h6><blockquote>
<p>实际的外点概率 $e$ 经常是未知的，如果外点特别多的话，$N$ 会非常大，也不利于计算</p>
</blockquote>
<p>步骤如下：<br>$N=∞,smaple_count=0$<br>While $N&gt;sample_count$ :<br>  选择一个样本并计算内点率 $1-e$（就是正常拟合后算出来阈值内的内点数，然后算个占比）；<br>  进一步计算出外点率 $e$ （就是1-内点率）<br>  根据 $N=log(1-p)/log(1-(1-e)^s)$ 更新 $N$<br>  $sample_count$++</p>
<p>【其实通过分析公式，可以看出 $e\propto N$，所以上面的自适应算法由于动态计算 $e$，就实现了动态调整 $N$】</p>
<h5 id="d-一致性-d"><a href="#d-一致性-d" class="headerlink" title="d. 一致性 d"></a>d. 一致性 d</h5><p>比如对于总共有100个点，我们可以设置d=50，迭代结束后：</p>
<ul>
<li>如果所有拟合结果的内点数（投票得分）都没到50，最终给出投票数最高的那个就行</li>
<li>如果有多个都到了50，除了最高的以外，这些高于50的也给出来，输出多条直线。<br>【因此可以通过设置d来控制结果要多条直线还是单条直线】</li>
</ul>
<h4 id="③-优缺点-1"><a href="#③-优缺点-1" class="headerlink" title="③ 优缺点"></a>③ 优缺点</h4><h5 id="a-优点"><a href="#a-优点" class="headerlink" title="a. 优点"></a>a. 优点</h5><ul>
<li>简单、通用</li>
<li>适用于许多不同问题</li>
<li>在实践中效果通常不错</li>
</ul>
<h5 id="b-缺点"><a href="#b-缺点" class="headerlink" title="b. 缺点"></a>b. 缺点</h5><ul>
<li>需要调整的参数很多</li>
<li>内点数比较低（外点数比较多）的时候，迭代次数太多</li>
<li>初始化不稳定，比如如果第一次外点数就爆多，那很坏了；<br>但是如果第一次内点数爆多，那说不定很快就解决了；<br>所以这初始化挺不稳定的</li>
</ul>
<h4 id="④-补充"><a href="#④-补充" class="headerlink" title="④ 补充"></a>④ 补充</h4><ul>
<li><strong>还是建议记忆一下 <font color="red">$e\propto N$</font></strong></li>
<li>真实应用时，其实需要针对特定问题和情况做更多改进，比如RANSAC最终得到最好的一根线，其实再用最小二乘去拟合这根线周围的点，得到的新直线会更好（<strong>细化</strong>）</li>
<li>RANSAC的一个实际应用的抽象示例——指纹匹配<br><img src="/../images/post13_images/6e8726c3c30421b22707a24a3d14a37a.png"></li>
</ul>
<h3 id="（5）霍夫变换"><a href="#（5）霍夫变换" class="headerlink" title="（5）霍夫变换"></a>（5）霍夫变换</h3><h4 id="①-引入——RANSAC无法解决的一些问题"><a href="#①-引入——RANSAC无法解决的一些问题" class="headerlink" title="① 引入——RANSAC无法解决的一些问题"></a>① 引入——RANSAC无法解决的一些问题</h4><p>如果只想检测下图的绿色直线，那么其他直线都是外点，外电太多了，RANSAC计算量爆炸，效果也受影响。<strong>RANSAC不好解决图像中存在大量线的情况</strong><br><img src="/../images/post13_images/3a81fcd271fa745accdb6f8887f7006f.png"></p>
<h4 id="②-霍夫变换需要满足的投票方案"><a href="#②-霍夫变换需要满足的投票方案" class="headerlink" title="② 霍夫变换需要满足的投票方案"></a>② 霍夫变换需要满足的投票方案</h4><h5 id="a-让每个特征为所有与其兼容的模型投票"><a href="#a-让每个特征为所有与其兼容的模型投票" class="headerlink" title="a. 让每个特征为所有与其兼容的模型投票"></a>a. 让每个特征为所有与其兼容的模型投票</h5><p>也就是说，对于一个点，谁能检测到它，它就给谁投票。都各自投完，最后选的模型依然是分数最高的那个。</p>
<h5 id="b-噪声点不可以一直为同一个模型投票。"><a href="#b-噪声点不可以一直为同一个模型投票。" class="headerlink" title="b, 噪声点不可以一直为同一个模型投票。"></a>b, 噪声点不可以一直为同一个模型投票。</h5><p>不能所有噪声点都投给一个模型，噪声本就是随机产生的，咋可能都投给一个模型，那根本没随机性，不能叫噪声了欸。</p>
<h5 id="c-只要足够多特征同意一个模型，缺失数据也并不重要（但也不能太多）"><a href="#c-只要足够多特征同意一个模型，缺失数据也并不重要（但也不能太多）" class="headerlink" title="c. 只要足够多特征同意一个模型，缺失数据也并不重要（但也不能太多）"></a>c. 只要足够多特征同意一个模型，缺失数据也并不重要（但也不能太多）</h5><p>只要得分高，有遮挡也无所谓，反正其他大部分特征都选择它了。正因如此，霍夫变换也可以解决遮挡问题。但遮挡的也不能太多，如果几乎全遮挡，剩下零散几个点也没办法确定目标的模型。</p>
<h4 id="③-霍夫变换的原理"><a href="#③-霍夫变换的原理" class="headerlink" title="③ 霍夫变换的原理"></a>③ 霍夫变换的原理</h4><p><img src="/../images/post13_images/73a276a70d3af4ce88629ea963d06206.png"><br>于是可以绘制出图像空间和参数空间：<br><img src="/../images/post13_images/0aaeea182babc24186d567abe68bc9a8.png"><br>当情况逐渐复杂：<br><img src="/../images/post13_images/f6810b84cc3184fbee66a1003a7ccf0d.png"></p>
<h4 id="④-霍夫变换的流程"><a href="#④-霍夫变换的流程" class="headerlink" title="④ 霍夫变换的流程"></a>④ 霍夫变换的流程</h4><p><img src="/../images/post13_images/deb7336fceb50058fd2b811c683e9870.png"><br>如果图像空间有其他的直线，那么在参数空间就会出现其他的极大值，这个可以在下面的例子中看到</p>
<h4 id="⑤-霍夫变换的检测示例（数学模型上）"><a href="#⑤-霍夫变换的检测示例（数学模型上）" class="headerlink" title="⑤ 霍夫变换的检测示例（数学模型上）"></a>⑤ 霍夫变换的检测示例（数学模型上）</h4><p>最简单的情况：<br><img src="/../images/post13_images/413ab608f19a4413d795686036913ca1.png"><br>稍微复杂的情况，多个点—多个拟合结果—多个局部极大值<br><img src="/../images/post13_images/d69554353046db95943f5d7c728dddd4.png"><br>多条线的情况，每条线一个局部最大值：<br><img src="/../images/post13_images/74fe3a9fd6abcbbb9455bab62e1927d2.png"></p>
<h4 id="⑥-传统霍夫变换的局限性"><a href="#⑥-传统霍夫变换的局限性" class="headerlink" title="⑥ 传统霍夫变换的局限性"></a>⑥ 传统霍夫变换的局限性</h4><p>对于垂直的线，没斜率，没法对应到参数空间：<br><img src="/../images/post13_images/ff5219d5c8e202fdd903a5155ee2d30a.png"><br>如果累加器设置的太小，那可能没包含我们涉及到的点；<br>如果累加器设置的太大，那就需要遍历所有斜率，对内存和计算能力要求太高</p>
<h4 id="⑦-改进：极坐标系下的霍夫变换"><a href="#⑦-改进：极坐标系下的霍夫变换" class="headerlink" title="⑦ 改进：极坐标系下的霍夫变换"></a>⑦ 改进：极坐标系下的霍夫变换</h4><h5 id="a-原理"><a href="#a-原理" class="headerlink" title="a. 原理"></a>a. 原理</h5><p>改用极坐标系，用 $\theta$ 表示方向，用 $\rho$ 表示原点到直线的距离<br><img src="/../images/post13_images/db86958451d8208354668ba5c98d5f3f.png"><br>$\theta$ 的范围显而易见；$\rho$ 的范围是因为图像有边界，最大也就是图像对角线的距离<br><img src="/../images/post13_images/a73152d8655be88123d56f1b5e60c04a.png"><br>同样可以找到局部极大值</p>
<h5 id="b-步骤"><a href="#b-步骤" class="headerlink" title="b. 步骤"></a>b. 步骤</h5><p><img src="/../images/post13_images/03c09fc27da03cd8ef998193bb14cf33.png"></p>
<h5 id="c-优点"><a href="#c-优点" class="headerlink" title="c. 优点"></a>c. 优点</h5><p>如上图，$\theta$ 有范围，可以遍历表示垂直的直线</p>
<h5 id="d-进一步改进提升效率"><a href="#d-进一步改进提升效率" class="headerlink" title="d. 进一步改进提升效率"></a>d. 进一步改进提升效率</h5><p>上图橙色问题是想表明，<strong>对于每个角度都遍历，计算量有点大，咋办</strong><br>解决方案：<br>可以先用边缘检测，拿到最大梯度方向，而边缘方向和梯度方向是垂直关系，则可以在这个方向（角度）进行极坐标霍夫变换。同时，也可以根据这个角度来设置一个小的范围，更加严谨地进行遍历~<br><img src="/../images/post13_images/e41a2804bca67c301a8d0eae86cf1d4b.png"></p>
<h4 id="⑧-霍夫变换的实例效果（实际任务上）"><a href="#⑧-霍夫变换的实例效果（实际任务上）" class="headerlink" title="⑧ 霍夫变换的实例效果（实际任务上）"></a>⑧ 霍夫变换的实例效果（实际任务上）</h4><p><img src="/../images/post13_images/8f2c5bfb1a134fcd703f2dcdcc9986d3.png"></p>
<h4 id="⑨-霍夫变换的影响因素与解决"><a href="#⑨-霍夫变换的影响因素与解决" class="headerlink" title="⑨ 霍夫变换的影响因素与解决"></a>⑨ 霍夫变换的影响因素与解决</h4><h5 id="a-（自身）噪声的影响"><a href="#a-（自身）噪声的影响" class="headerlink" title="a. （自身）噪声的影响"></a>a. （自身）噪声的影响</h5><h6 id="i-影响"><a href="#i-影响" class="headerlink" title="i. 影响"></a>i. 影响</h6><p>一个例子：<br><img src="/../images/post13_images/bb0610b62968e544667895a56112a01d.png"><br>噪声大小和投票数最大值的关系图（以20个点的图为例）：<br><img src="/../images/post13_images/e057758a1640889701a9e56c35be08b5.png"><br>可以看出噪声越大，票数峰值越小，对投票的影响越大<br>即<strong>噪声越大，霍夫变换性能越差</strong></p>
<h5 id="b-（外部噪声）随机点的影响"><a href="#b-（外部噪声）随机点的影响" class="headerlink" title="b. （外部噪声）随机点的影响"></a>b. （外部噪声）随机点的影响</h5><blockquote>
<p>随机点是外部随机生成的噪声点，和刚才那个自身的噪声不一样，这个是外部随机出现在图像中的随机点。<strong>一个是自身的，一个是外部的。</strong></p>
</blockquote>
<p>一个例子：<br><img src="/../images/post13_images/421b9dca92ab9934ff7aa706fc41e70b.png"><br>随着随机点噪声的增大，越有可能出现虚假峰值（伪峰值），也就是由这些随机噪声点投票出来了一个结果，而不是我们本来的数据。<br><img src="/../images/post13_images/630f60c8c6e351c3f5d841417a020aaf.png"><br>如上图所示，随机点越多，伪峰值越可能出现。</p>
<h5 id="c-解决"><a href="#c-解决" class="headerlink" title="c. 解决"></a>c. 解决</h5><ul>
<li>方法1：在对参数空间进行离散化时，选取一个合适大小的网格<br>不能太大，也不能太小<br><img src="/../images/post13_images/25330ae90951c7114fefc3d989d4d20e.png"></li>
<li>方法2：软投票——不采用“落在某个格子”来投票，而用“距离”来投票<br>相当于一票掰开好多份，给近的多些，给远的少些</li>
<li>方法3：尝试去掉不相关的特征，只选择具有明显梯度的边缘做霍夫变换</li>
</ul>
<h4 id="⑩-霍夫变换检测圆形"><a href="#⑩-霍夫变换检测圆形" class="headerlink" title="⑩ 霍夫变换检测圆形"></a>⑩ 霍夫变换检测圆形</h4><h5 id="a-原理-1"><a href="#a-原理-1" class="headerlink" title="a. 原理"></a>a. 原理</h5><p>圆的方程：$(x-u)^2+(y-v)^2=r^2$，其中 $(u,v)$ 是圆心，$r$ 是半径<br>一个圆由三个参数确定：$u,v,r$<br>依旧是从图像空间变换到参数空间<br>读懂下面的图，需要先进行以下理解：</p>
<ul>
<li>图像空间的一个圆，可以用三个参数表示：圆心坐标 $(x, y)$ 和半径 $r$ 。所以，<strong>图像中一个圆，可以用三维参数空间中一个点来表示</strong></li>
<li>一个点如果在图像中的某个圆上，那它和圆心所成的方向，是该点<strong>图像梯度的方向</strong></li>
<li>已知的某点图像梯度方向，经过图像中某一个点的所有可能的圆，可以在x,y,r三维空间中用<strong>两根直线</strong>表示。<br>（如果不考虑该点梯度方向，则笛卡尔坐标系中某一个点，其所有可能的圆，在参数空间中可以用一个<strong>立体圆锥曲面</strong>表示！）</li>
<li>对于图像中某个像素点 $(x,y)$ ，当给定 $r$ 半径值后，仅有<strong>两个可能的圆心位置</strong>（这两个潜在可能的圆心位置相对这个像素点<strong>互为镜像位置</strong>），这两个圆心的位置可以通过x，y，r，以及图像梯度角度值计算出来。<br><img src="/../images/post13_images/15edeb7edb21b596af6c8898dba09c5d.png"></li>
</ul>
<h4 id="⑪-广义霍夫变换"><a href="#⑪-广义霍夫变换" class="headerlink" title="⑪ 广义霍夫变换"></a>⑪ 广义霍夫变换</h4><h5 id="a-动机"><a href="#a-动机" class="headerlink" title="a. 动机"></a>a. 动机</h5><blockquote>
<p>普通霍夫变换需要用方程描述要检测的形状，从而获得图像空间到参数空间的变换，但有些形状很难用方程参数化描述</p>
</blockquote>
<p>拟合无法用方程描述的形状</p>
<h5 id="b-原理"><a href="#b-原理" class="headerlink" title="b. 原理"></a>b. 原理</h5><p>我们的目的：找到一个能表示这个形状的参考点，最终模型可以表示这个参考点<br>例如下图的不规则形状，怎么做：</p>
<ul>
<li>先假设参考点是 $(x_c,y_c)$，这个参考点的具体坐标我们不知道，只是先设出来。</li>
<li>然后对于边缘上的所有点，每个点都要计算：<ul>
<li>$r$ ：点到参考点的距离</li>
<li>$\alpha$：点和参考点连线与水平方向的夹角</li>
<li>$\phi$ ：点的梯度方向（注意图中说的边缘方向实际上是想说边缘梯度方向）</li>
</ul>
</li>
<li>统计梯度方向的投票情况。如图中的 $\phi_i$，可以看出多个点可能存在相同的梯度方向</li>
<li>取出投每个梯度方向，拿到各自所包含的点，进行投票。<br><img src="/../images/post13_images/63bcc2c1dbab49373a0e66292d3c64d3.png"></li>
</ul>
<h5 id="c-流程"><a href="#c-流程" class="headerlink" title="c. 流程"></a>c. 流程</h5><p><img src="/../images/post13_images/42703432f4e82ba1dc05262b96d64f01.png"></p>
<h5 id="d-改进"><a href="#d-改进" class="headerlink" title="d. 改进"></a>d. 改进</h5><p>存在问题：无法应对旋转<br><img src="/../images/post13_images/395080a9329ba46d7742fb126b9162ad.png"><br>改进方式：引入更多参数<br><img src="/../images/post13_images/0cf0d21bcc39a3395793fde56bd9cace.png"></p>
<h5 id="e-应用"><a href="#e-应用" class="headerlink" title="e. 应用"></a>e. 应用</h5><p>除了检测形状以外，还可以通过检测一些大物体的局部组件相对大物体的位置关系，通过方向投票机制，去锁定图像中某大物体的中心位置。<br><img src="/../images/post13_images/cb3a0a2d7a6ccf5cc239c6f5e984d869.png"></p>
<h4 id="⑫-霍夫变换的优缺点"><a href="#⑫-霍夫变换的优缺点" class="headerlink" title="⑫ 霍夫变换的优缺点"></a>⑫ 霍夫变换的优缺点</h4><h5 id="a-优点-1"><a href="#a-优点-1" class="headerlink" title="a. 优点"></a>a. 优点</h5><ul>
<li>可以处理非局部性的（全局的）和遮挡的情况</li>
<li>可以检测出多个模型的实例（就是拟合出多个符合要求的模型出来）</li>
<li>对噪声比较鲁棒（这是前提条件了，见第②部分）</li>
</ul>
<h5 id="b-缺点-1"><a href="#b-缺点-1" class="headerlink" title="b. 缺点"></a>b. 缺点</h5><ul>
<li>随着模型参数的增加，搜索空间变越来越大，搜索时间复杂度指数级增长</li>
<li>非形状目标可能会在参数空间中产生虚假峰值（伪峰值）</li>
<li>很难选择一个合适的网格大小（见⑨.c）</li>
</ul>
<h2 id="3-拟合方法的选择"><a href="#3-拟合方法的选择" class="headerlink" title="3. 拟合方法的选择"></a>3. 拟合方法的选择</h2><p><img src="/../images/post13_images/275a8a32d3475d58bf586ae9ebbfbd3c.png"></p>
<h1 id="六、局部特征"><a href="#六、局部特征" class="headerlink" title="六、局部特征"></a>六、局部特征</h1><h2 id="1-角点检测"><a href="#1-角点检测" class="headerlink" title="1. 角点检测"></a>1. 角点检测</h2><h3 id="（1）为什么要提取特征"><a href="#（1）为什么要提取特征" class="headerlink" title="（1）为什么要提取特征"></a>（1）为什么要提取特征</h3><h4 id="动机：全景拼接"><a href="#动机：全景拼接" class="headerlink" title="动机：全景拼接"></a>动机：全景拼接</h4><blockquote>
<p>摄像机视角有限，因此需要转动在多视角进行拍摄，完成全景图像。</p>
</blockquote>
<h5 id="a-流程"><a href="#a-流程" class="headerlink" title="a. 流程"></a>a. 流程</h5><p>提取特征 –&gt; 进行特征匹配 –&gt; 根据匹配得到的联系，拼接图像</p>
<h5 id="b-良好特征的性质（提取哪些特征才更适配任务）"><a href="#b-良好特征的性质（提取哪些特征才更适配任务）" class="headerlink" title="b. 良好特征的性质（提取哪些特征才更适配任务）"></a>b. 良好特征的性质（提取哪些特征才更适配任务）</h5><ul>
<li>可重复性：在几幅图像中可以找到的共同特征</li>
<li>显著性：显著区别于其他的特征</li>
<li>紧凑性和效率：希望特征能比图像像素少得多，从而计算是高效的</li>
<li>局部性：特征只跟其周围的图像有关系（在图像中占据相对较小的区域），对杂乱和遮挡具有鲁棒性</li>
</ul>
<h5 id="c-特征点的应用"><a href="#c-特征点的应用" class="headerlink" title="c. 特征点的应用"></a>c. 特征点的应用</h5><p>图像对齐、3D重建、运动跟踪、机器人导航、索引和数据库检索、物体识别……</p>
<h3 id="（2）角点"><a href="#（2）角点" class="headerlink" title="（2）角点"></a>（2）角点</h3><h4 id="①-角点的定义"><a href="#①-角点的定义" class="headerlink" title="① 角点的定义"></a>① 角点的定义</h4><p>图像梯度在两个方向或更多方向上发生了突变的地方</p>
<h4 id="②-角点的性质"><a href="#②-角点的性质" class="headerlink" title="② 角点的性质"></a>② 角点的性质</h4><p>角点具有可重复性、显著性、紧凑性（时间计算效率高）、局部性</p>
<h4 id="③-判断是否是角点"><a href="#③-判断是否是角点" class="headerlink" title="③ 判断是否是角点"></a>③ 判断是否是角点</h4><h5 id="a-直观描述"><a href="#a-直观描述" class="headerlink" title="a. 直观描述"></a>a. 直观描述</h5><p><img src="/../images/post13_images/1c78897a756fa731f684b9d86a6b3bfb.png"><br>如果是角点，窗口至少沿着两个方向移动会发生变化</p>
<h5 id="b-数值描述"><a href="#b-数值描述" class="headerlink" title="b. 数值描述"></a>b. 数值描述</h5><p>$E(u, v) = \sum_{x, y} w(x, y) \left[ I(x + u, y + v) - I(x, y) \right]^2$</p>
<p><img src="/../images/post13_images/33dd7bd924045b7c00cba30ed7a3cbc8.png"></p>
<ul>
<li>$u,v$：平移量</li>
<li>$I(x,y)$：没有移动前的图像强度</li>
<li>$I(x+u,y+v)$：移动后的图像强度</li>
<li>$E(u,v)$：窗口移动前后像素值的差异；</li>
<li>$w(x,y)$：权值，可根据每个点对整个E(u,v)的贡献的差异特异化设置</li>
</ul>
<p><strong>i. 将E(u,v)进行二阶泰勒展开，以观测在很小的移动下E(u,v)的数值表现（E(u,v)和u,v的关系会更加直观）：</strong><br><img src="/../images/post13_images/ecf8e088532ae18f6981a67e69e0cc8c.png"><br><strong>ii. 计算上式中涉及到的偏导数：</strong><br><img src="/../images/post13_images/5da01acc050884586c8f4624a717c8d8.png"><br><strong>iii. 代入数值并整理得到最终二阶泰勒展开式化简结果：</strong><br><img src="/../images/post13_images/3c4995c84cb467ceaba233bb6328e721.png"><br><strong>iv. 理解M矩阵：</strong></p>
<ul>
<li>假设窗口检测到的信号是垂直关系的，则有 $I_x I_y = 0$，则M可以转化成下图特征值的形式：<br><img src="/../images/post13_images/b9aebc64e9a48e495c3a9bb7fdca000c.png"></li>
<li><ul>
<li>如果点位于垂直的边缘，即 $I_x≠0，I_y =0$ ：<br>则 $M = \begin{bmatrix}\lambda_1 &amp; 0 \0 &amp; 0\end{bmatrix}，E(u,v)=λ_1u^2$<br>则 $u$变，$E(u,v)$变；$v$变，$E(u,v)$不变</li>
</ul>
</li>
<li><ul>
<li>如果点位于水平的边缘，即 $I_x=0，I_y ≠0$ ：<br>则 $M = \begin{bmatrix}\ 0&amp; 0 \0 &amp; \lambda_2\end{bmatrix}，E(u,v)=λ_2v^2$<br>则 $u$变，$E(u,v)$不变；$v$变，$E(u,v)$变</li>
</ul>
</li>
</ul>
<p>所以，只有 $λ_1$ 和 $λ_2$ 都不为0（或接近0）时，角点才存在</p>
<ul>
<li>假设窗口检测到的信号存在旋转，则M是一个实对称矩阵：<br> $M = \begin{bmatrix} a &amp; c \c &amp; a\end{bmatrix}，c≠0$，<br>则可以进行对角化：$M = R^{-1}\begin{bmatrix}\lambda_1 &amp; 0 \0 &amp; \lambda_2\end{bmatrix}R, R$是一个正交矩阵<br>同样等于$M = R^{T}\begin{bmatrix}\lambda_1 &amp; 0 \0 &amp; \lambda_2\end{bmatrix}R$</li>
</ul>
<p>所以，无论是否存在旋转，都可以通过上述方法只分析 $λ_1$ 和 $λ_2$ ‘<br><strong>v. E(u,v)在数学上是椭圆</strong></p>
<ul>
<li>课程中，首先是针对$I_x≠0，I_y =0$ 的情况，进行化简发现$E(u,v)$满足椭圆方程，是一个正椭圆，而刚才第四部分对M的讨论的第二种情况，存在旋转，即一个旋转的椭圆。</li>
<li>在形式上，椭圆的轴长由 $λ_1$ 和 $λ_2$确定，方向由$R$确定</li>
<li>$λ_1$ 和 $λ_2$ 越大，轴越短 ； $λ_1$ 和 $λ_2$ 越小，轴越长<br><img src="/../images/post13_images/1c7291a49768036eecda238a0681b3e2.png"></li>
</ul>
<p><strong>vi. 二阶矩矩阵M的可视化</strong><br><img src="/../images/post13_images/677a2434fa4e0a1504ed546c02b55c35.png"></p>
<p><strong>vii. 阶段总结</strong></p>
<ul>
<li>$λ_1=0$ 或 $λ_2=0$ ，点在边</li>
<li>$λ_1≠0$ 且 $λ_2≠0$ 且都非常大，角点</li>
<li>$λ_1=0$ 且 $λ_2=0$ 或都非常小，平坦区域</li>
</ul>
<p><strong>viii. 阈值R</strong><br>Q：多大算非常大？这不方便人工设定<br><strong>A：$R = \det(M) - \alpha , (\mathrm{tr}(M))^2 = \lambda_1 \lambda_2 - \alpha (\lambda_1 + \lambda_2)^2$</strong><br><strong>其中 $tr(M)$ 是矩阵的迹，是主对角线元素之和</strong><br><strong>$R&gt;0$，则是角点</strong><br><strong>$R&lt;0$，则是边缘</strong><br><strong>$R→0$，则是平坦区域</strong></p>
<h5 id="c-Harris角点检测"><a href="#c-Harris角点检测" class="headerlink" title="c. Harris角点检测"></a>c. Harris角点检测</h5><p>Harris角点检测就是上面的数值描述方法，总结一下：</p>
<ul>
<li>先在每个像素处计算高斯导数，也就是$I_x$和$I_y$，相关计算见b.ii</li>
<li>然后计算每个像素周围高斯窗口的二阶矩矩阵M，相关计算见b.iii</li>
<li>然后计算角点响应函数R，相关计算见b.viii</li>
<li>将R作为阈值来判断是否是角点，相关判断见b.viii</li>
<li>最后进行非极大值抑制，找到响应函数的局部最大值</li>
</ul>
<p>最后一步的是因为：某一个点是角点（响应较高）时，周围的点可能也是如此。找到最高的即可。  </p>
<h3 id="（3）Harris角点的特性"><a href="#（3）Harris角点的特性" class="headerlink" title="（3）Harris角点的特性"></a>（3）Harris角点的特性</h3><h4 id="①-好的特征具备的四个特性"><a href="#①-好的特征具备的四个特性" class="headerlink" title="① 好的特征具备的四个特性"></a>① 好的特征具备的四个特性</h4><p>可重复性、显著性、计算高效（紧凑性）、局部性</p>
<h4 id="②-Invariance-和-Covariance-的区别"><a href="#②-Invariance-和-Covariance-的区别" class="headerlink" title="② Invariance 和 Covariance 的区别"></a>② Invariance 和 Covariance 的区别</h4><ul>
<li>Invariance：$F(I)=F[T(I)]$<br>即图像变化前后，用同一个特征提取器$F$提取到的特征是相同的</li>
<li>Covariance：$F(I)≠F[T(I)]$，但$T’[F(I)]=F[T(I)]$<br>即对原始图像提取的特征做变换后，与变换后的图像提取到的特征是相同的</li>
</ul>
<p><strong>所以，好的特征应当具备Invariance特性，实在不行，Covariance特性也可以</strong></p>
<h4 id="③-探究Harris角点是否具有Invariance-Covariance特性"><a href="#③-探究Harris角点是否具有Invariance-Covariance特性" class="headerlink" title="③ 探究Harris角点是否具有Invariance/Covariance特性"></a>③ 探究Harris角点是否具有Invariance/Covariance特性</h4><h5 id="a-对图像强度进行变化"><a href="#a-对图像强度进行变化" class="headerlink" title="a. 对图像强度进行变化"></a>a. 对图像强度进行变化</h5><p>加光照，$I → I+b$，并不改变梯度变化，对$M$矩阵无影响，因此还能检测到角点，<strong>满足Invariance</strong></p>
<h5 id="b-对图像进行尺度变化（缩放）"><a href="#b-对图像进行尺度变化（缩放）" class="headerlink" title="b, 对图像进行尺度变化（缩放）"></a>b, 对图像进行尺度变化（缩放）</h5><p>缩放，$I → αI$，可能将原本低于$R$阈值的响应点也检测为角点，<strong>不满足Invariance和Covariance</strong>，如图：<br><img src="/../images/post13_images/eb06cee6da5ca4d10c58723d04aef8b8.png"></p>
<h5 id="c-对图像进行平移或旋转"><a href="#c-对图像进行平移或旋转" class="headerlink" title="c, 对图像进行平移或旋转"></a>c, 对图像进行平移或旋转</h5><p>平移或旋转不改变梯度，还是能够检测到角点，但平移或旋转前后提取到的特征不相同，<strong>不满足Invariance</strong>；但把平移后得到的特征再变化，就相同了，<strong>满足Covariance</strong></p>
<h5 id="d-结论"><a href="#d-结论" class="headerlink" title="d. 结论"></a>d. 结论</h5><p>Harris角点检测对于仿射变换具有<strong>部分</strong>的不变性<br>Harris角点检测不具备尺度不变性<br>如果相机和场景距离固定（图像尺度不变），Harris角点检测可行，反之不可行</p>
<hr>
<h2 id="2-Blob检测"><a href="#2-Blob检测" class="headerlink" title="2. Blob检测"></a>2. Blob检测</h2><blockquote>
<p>Blob检测具有尺度不变性，而Harris角点检测不具备尺度不变性</p>
</blockquote>
<h3 id="（1）Blob（斑点）"><a href="#（1）Blob（斑点）" class="headerlink" title="（1）Blob（斑点）"></a>（1）Blob（斑点）</h3><h4 id="①-定义："><a href="#①-定义：" class="headerlink" title="① 定义："></a>① 定义：</h4><p>二维图像跟周围有着明显颜色和灰度变化的区域</p>
<blockquote>
<p>斑点可以是一个区域，但角点只是一个点，因此斑点具有<strong>更好的稳定性和抗干扰能力</strong></p>
</blockquote>
<h4 id="②-斑点的尺度寻找"><a href="#②-斑点的尺度寻找" class="headerlink" title="② 斑点的尺度寻找"></a>② 斑点的尺度寻找</h4><p>找到一个函数，从而自适应尺度的变化，因此有尺度不变性<br><img src="/../images/post13_images/fc7f5fed3f567897168db5d6d8af4d16.png"></p>
<blockquote>
<p>回顾边缘检测</p>
</blockquote>
<h5 id="a-高斯一阶偏导核"><a href="#a-高斯一阶偏导核" class="headerlink" title="a. 高斯一阶偏导核"></a>a. 高斯一阶偏导核</h5><p><img src="/../images/post13_images/938235066e8c47e45724d511464633f8.png"></p>
<h5 id="b-高斯二阶偏导核（拉普拉斯核）"><a href="#b-高斯二阶偏导核（拉普拉斯核）" class="headerlink" title="b. 高斯二阶偏导核（拉普拉斯核）"></a>b. 高斯二阶偏导核（拉普拉斯核）</h5><p><img src="/../images/post13_images/0bd611aa56f53df69370dd3910ac4250.png"></p>
<h5 id="c-通过拉普拉斯核找到最优尺度"><a href="#c-通过拉普拉斯核找到最优尺度" class="headerlink" title="c. 通过拉普拉斯核找到最优尺度"></a>c. 通过拉普拉斯核找到最优尺度</h5><p><img src="/../images/post13_images/eec9eeba1a6ee1b9012d8174825b23a0.png"><br>在实际应用中，由于不知道信号长什么样，会设置多个不同方差的拉普拉斯核去卷积，从而才能选择到最好的。</p>
<h5 id="d-拉普拉斯核方差的选择"><a href="#d-拉普拉斯核方差的选择" class="headerlink" title="d. 拉普拉斯核方差的选择"></a>d. 拉普拉斯核方差的选择</h5><p><strong>问题</strong>：随着方差$σ$逐渐变大，信号会逐渐衰减，很难找到极值点<br><strong>原因</strong>：<br><img src="/../images/post13_images/486dcbdb3deaa9e7eaff10174a447aaa.png"></p>
<ul>
<li>数学理解：$σ$越大，图中面积越小，产生出的信号相应越小。（图中仅是高斯一阶偏导核，而二阶会受到更强烈的影响）</li>
<li>物理理解：高斯核去噪，$σ$越大，去噪效果越强，把高频信号都去掉了，原本响应值突出的区域也都因此变得平坦了</li>
</ul>
<p><strong>解决</strong>：需要对信号进行补偿，给拉普拉斯核乘上一个$σ^2$：$\nabla^2_{\text{norm}} g = \sigma^2 \left( \frac{\partial^2 g}{\partial x^2} + \frac{\partial^2 g}{\partial y^2} \right)$<br>  从而把分母上的$σ^2$约掉，效果如图，可以找到我们想要的函数曲线了：<br>  <img src="/../images/post13_images/9337869d8a3f92af9b40847f83b40a24.png"><br>  横轴是方差变化，也就是尺度变化；纵轴是响应值变化</p>
<h5 id="e-拉普拉斯核方差和信号半径的关系"><a href="#e-拉普拉斯核方差和信号半径的关系" class="headerlink" title="e. 拉普拉斯核方差和信号半径的关系"></a>e. 拉普拉斯核方差和信号半径的关系</h5><p>当拉普拉斯核的过零点的宽度和信号的直径恰好相等时，响应值最大<br><img src="/../images/post13_images/329ea11f49265c8469c8a094fc9e00a7.png"><br><strong>此时也存在关系：</strong> $r=\sqrt{2}σ$<br>这个的计算方式就是让拉普拉斯核等于0（过零点），结合本身斑点存在的关系 $x^2+y^2=r^2$（圆），化简得到了。</p>
<blockquote>
<p>大方差，大窗宽，检测大信号；小方差，小窗宽，检测小信号</p>
</blockquote>
<h5 id="f-斑点检测的非极大值抑制"><a href="#f-斑点检测的非极大值抑制" class="headerlink" title="f, 斑点检测的非极大值抑制"></a>f, 斑点检测的非极大值抑制</h5><p>由于检测时，相邻区域的点可能响应值都很大，因此步骤：</p>
<ul>
<li>取下图三个尺度的27个点的响应值</li>
<li>对最大响应值对应的点，作为圆心，根据对应尺度和计算出的半径画圆<br><img src="/../images/post13_images/73e6d157f96ba59af5c36f60a2188afc.png"><br>（此图假设检测模板是3×3的，同时在实际检测中一般仅比较相邻三个的尺度如图所示）</li>
</ul>
<h4 id="③-斑点检测计算量大的解决办法"><a href="#③-斑点检测计算量大的解决办法" class="headerlink" title="③ 斑点检测计算量大的解决办法"></a>③ 斑点检测计算量大的解决办法</h4><h5 id="a-和Harris角点检测相结合"><a href="#a-和Harris角点检测相结合" class="headerlink" title="a. 和Harris角点检测相结合"></a>a. 和Harris角点检测相结合</h5><ul>
<li>先用Harris角点检测，把角点检测出来</li>
<li>在每个角点周围，建立一个尺度空间，看周围有没有合适尺度（斑点检测画圆）</li>
</ul>
<h5 id="b-SIFT特征"><a href="#b-SIFT特征" class="headerlink" title="b. SIFT特征"></a>b. SIFT特征</h5><p>见下</p>
<h3 id="（2）SIFT"><a href="#（2）SIFT" class="headerlink" title="（2）SIFT"></a>（2）SIFT</h3><h4 id="①-高斯差分"><a href="#①-高斯差分" class="headerlink" title="① 高斯差分"></a>① 高斯差分</h4><h5 id="a-定义"><a href="#a-定义" class="headerlink" title="a. 定义"></a>a. 定义</h5><p>两个高斯核做差<br><img src="/../images/post13_images/75d109bce06eef976fbe69fcdb8d9002.png"></p>
<h5 id="b-优势——效率提升方式"><a href="#b-优势——效率提升方式" class="headerlink" title="b. 优势——效率提升方式"></a>b. 优势——效率提升方式</h5><ul>
<li>高斯差分和拉普拉斯之间就差了一个常数：$k-1$，则：高斯函数→高斯差分→拉普拉斯<br><img src="/../images/post13_images/0b436b76b01c215960b476753271bf50.png"><br>（图中这样一组空间成为一个Octave——八度）</li>
<li>在构建高斯空间时，可以利用”过两个小的等于过一个大的，关系是$\sqrt2$ 的性质，来得到其他尺度的高斯层    【<strong>Octave组内加速</strong>】</li>
<li>如果不想用大方差的拉普拉斯核和大信号做卷积，可以通过：<br>先把图像进行缩放，用小方差的卷积核与缩放后的图像做卷积，找到的尺度空间再乘回缩放倍数<br>这样可以避免一直增大卷积核的方差不断做卷积构成新的Octave，直接用原来的小方差卷积核就可以构建新的Octave了<br>所以在实际应用中，对于1-8的尺度，可以：尺度为1-2时，用原图计算；2-4时，用1/2原图计算；4-8时，用1/4原图计算。拼起来就可以得到连续的尺度空间。<br>【<strong>Octave组间加速</strong>】</li>
</ul>
<h5 id="c-如何设置k的数值"><a href="#c-如何设置k的数值" class="headerlink" title="c. 如何设置k的数值"></a>c. 如何设置k的数值</h5><p> $k=2^{1/S}$，因为只有满足这个关系才能构建连续的尺度空间<br> S是怎么来的：</p>
<ul>
<li>对于5层高斯空间，有4层高斯差分空间，则有4层拉普拉斯空间，我们在前面说过，一般仅比较相邻三个的尺度，则有两种可能，S=2（123、234两种可能）</li>
<li>对于6层高斯空间，同理，则有三种可能，S=3（123、234、345三种可能）</li>
</ul>
<h4 id="②-SIFT特征的特性"><a href="#②-SIFT特征的特性" class="headerlink" title="② SIFT特征的特性"></a>② SIFT特征的特性</h4><h5 id="a-拉普拉斯相应的Invariance"><a href="#a-拉普拉斯相应的Invariance" class="headerlink" title="a. 拉普拉斯相应的Invariance"></a>a. 拉普拉斯相应的Invariance</h5><p>当图像进行旋转或缩放时，拉普拉斯算子计算出的响应值不会改变。</p>
<h5 id="b-斑点位置和尺度的Covariance"><a href="#b-斑点位置和尺度的Covariance" class="headerlink" title="b. 斑点位置和尺度的Covariance"></a>b. 斑点位置和尺度的Covariance</h5><p>当图像进行旋转或缩放时，检测到的“blob”的位置和尺度会相应地变化。</p>
<h5 id="c-对于强度、角度、形状变化不满足Invariance和Covariance"><a href="#c-对于强度、角度、形状变化不满足Invariance和Covariance" class="headerlink" title="c. 对于强度、角度、形状变化不满足Invariance和Covariance"></a>c. 对于强度、角度、形状变化不满足Invariance和Covariance</h5><p>角度和形变的解决方案：经过大小归一化变成椭圆，再利用梯度方向直方图按梯度最强方向进行旋转（梯度方向直方图见下）<br>强度（光照）变化的解决方案：SIFT描述子投票（SIFT描述子见下）</p>
<blockquote>
<p>大小归一化：计算出M矩阵，微调$λ_1$和$λ_2$，把小的变大一点，迭代微调，直到$λ_1$和$λ_2$相等，相当于接近于原始的正圆了<br>【不确定理解的是否正确，老师在这里的讲解逻辑很混乱，讲的不太好这里】</p>
</blockquote>
<h4 id="③-梯度方向直方图"><a href="#③-梯度方向直方图" class="headerlink" title="③ 梯度方向直方图"></a>③ 梯度方向直方图</h4><p>梯度强度：$\sqrt{I_x^2+I_y^2}$<br>梯度方向：$arctan\sqrt{I_x^2+I_y^2}$<br>箭头方向表示梯度方向，箭头长度表示梯度强度<br><img src="/../images/post13_images/98c8ee16179daff71acc3a4ec9e687f7.png"></p>
<h4 id="④-SIFT描述子"><a href="#④-SIFT描述子" class="headerlink" title="④ SIFT描述子"></a>④ SIFT描述子</h4><p>将小区域进行划分<br>1个区域划分为16个小区域，每个小区域存在8个方向，因此共有$16×8=128$维特征<br><img src="/../images/post13_images/1e3de9e6d21c4a68890e99e59827525f.png"></p>
<h2 id="3-纹理特征"><a href="#3-纹理特征" class="headerlink" title="3. 纹理特征"></a>3. 纹理特征</h2><h3 id="（1）纹理（Texture）"><a href="#（1）纹理（Texture）" class="headerlink" title="（1）纹理（Texture）"></a>（1）纹理（Texture）</h3><h4 id="①-定义"><a href="#①-定义" class="headerlink" title="① 定义"></a>① 定义</h4><p>某种基元以某种方式组合起来</p>
<h4 id="②-分类"><a href="#②-分类" class="headerlink" title="② 分类"></a>② 分类</h4><ul>
<li>规则的纹理</li>
<li>不规则的纹理</li>
</ul>
<h4 id="③-用途"><a href="#③-用途" class="headerlink" title="③ 用途"></a>③ 用途</h4><ul>
<li>从纹理中恢复形状信息</li>
<li>应用于分割、分类任务【课程主要关注】<br>（可以帮助我们区分事物、划分类别等）</li>
<li>应用于合成任务</li>
</ul>
<h4 id="④-纹理的重要性"><a href="#④-纹理的重要性" class="headerlink" title="④ 纹理的重要性"></a>④ 纹理的重要性</h4><ul>
<li>通常表示了材料的特性</li>
<li>可能是重要的外观线索，特别是在物体形状相似的情况下</li>
<li>旨在区分形状、边界和纹理</li>
</ul>
<h3 id="（2）纹理特征的提取"><a href="#（2）纹理特征的提取" class="headerlink" title="（2）纹理特征的提取"></a>（2）纹理特征的提取</h3><h4 id="①-发现模式（Pattern）"><a href="#①-发现模式（Pattern）" class="headerlink" title="① 发现模式（Pattern）"></a>① 发现模式（Pattern）</h4><blockquote>
<p>模式就是某种规则、规律</p>
</blockquote>
<p>利用斑点检测器、角点检测器、边缘检测器…检测出基础的元素</p>
<h4 id="②-描述纹理"><a href="#②-描述纹理" class="headerlink" title="② 描述纹理"></a>② 描述纹理</h4><p>利用统计的方法：平均值、标准差、直方图…</p>
<h4 id="③-示例"><a href="#③-示例" class="headerlink" title="③ 示例"></a>③ 示例</h4><p><img src="/../images/post13_images/336e64283bcade1b026fb889cef74fe9.png"><br><img src="/../images/post13_images/1167a7522edd8b3b177b08f0ed086765.png"><br>其中，<br><img src="/../images/post13_images/8be32f58e506354de3cfc05fae430315.png"><br>$D(a,b)=\sqrt{(a_1-b_1)^2+(a_2-b_2)^2+(a_3-b_3)^2} = \sqrt{\sum_{i=1}^{3} (a_i - b_i)^2}$</p>
<h4 id="④-Filter-banks（滤波器组-卷积核组）"><a href="#④-Filter-banks（滤波器组-卷积核组）" class="headerlink" title="④ Filter banks（滤波器组/卷积核组）"></a>④ Filter banks（滤波器组/卷积核组）</h4><h5 id="a-背景"><a href="#a-背景" class="headerlink" title="a. 背景"></a>a. 背景</h5><p>在③示例中，使用了两个滤波器分别在x和y两个方向上做卷积，产生了二维特征向量，用于描述窗口中的纹理特征。</p>
<h5 id="b-引入"><a href="#b-引入" class="headerlink" title="b. 引入"></a>b. 引入</h5><p>推广，应用一组d个滤波器，产生d维特征向量</p>
<h5 id="c-形式"><a href="#c-形式" class="headerlink" title="c. 形式"></a>c. 形式</h5><p>如图所示48维的滤波器组<br><img src="/../images/post13_images/722d46bd0c22b46e2b1bebeeb7397062.png"><br>每个窗口纹理被映射为48维空间的一个点，是一个48维的特征向量，这个点具有48维的特征</p>
<h5 id="d-多维高斯（Multivariate-Gaussian）"><a href="#d-多维高斯（Multivariate-Gaussian）" class="headerlink" title="d. 多维高斯（Multivariate Gaussian）"></a>d. 多维高斯（Multivariate Gaussian）</h5><p>展现了协方差矩阵和高斯核之间的关系：<br><img src="/../images/post13_images/51d72ea41f04ff2ac2093e35fd9b69ab.png"><br>在 Filter banks中的48个滤波器就是通过如上编程定义（不同方向）</p>
<h5 id="e-Filter-bank-应用示例"><a href="#e-Filter-bank-应用示例" class="headerlink" title="e. Filter bank 应用示例"></a>e. Filter bank 应用示例</h5><p>应用一个38维的Filter bank做卷积：<br><img src="/../images/post13_images/ba335962a9b95ff650748d0554f7a385.png"><br>一个匹配quiz：<br><img src="/../images/post13_images/1e7cfa90899fd73dbc22ab9996be4d0a.png"></p>
<h5 id="f-Fliter-bank-卷积结果的应用"><a href="#f-Fliter-bank-卷积结果的应用" class="headerlink" title="f. Fliter bank 卷积结果的应用"></a>f. Fliter bank 卷积结果的应用</h5><h6 id="i-对整个图像卷积"><a href="#i-对整个图像卷积" class="headerlink" title="i. 对整个图像卷积"></a>i. 对整个图像卷积</h6><p>一张图像，x维Filter bank卷积，得到x个卷积响应，对这x个卷积响应计算平均，得到了一个图像的x维特征向量，表示了图像</p>
<h6 id="ii-对每个像素点卷积"><a href="#ii-对每个像素点卷积" class="headerlink" title="ii. 对每个像素点卷积"></a>ii. 对每个像素点卷积</h6><p>对一张图像的所有像素点，x维Filter bank卷积，每个像素得到x个卷积响应</p>
<h3 id="（3）纹理检测在视觉任务中的应用"><a href="#（3）纹理检测在视觉任务中的应用" class="headerlink" title="（3）纹理检测在视觉任务中的应用"></a>（3）纹理检测在视觉任务中的应用</h3><ul>
<li>通过Filter bank检索相似纹理 / 通过相似纹理的检索进一步进行图像分类任务</li>
<li>通过纹理来区分场景（其实也是分类任务）</li>
<li>通过纹理来进行图像分割，通过纹理让图像中的各部分进行了分类，从而分开了</li>
</ul>
<h1 id="七、分割"><a href="#七、分割" class="headerlink" title="七、分割"></a>七、分割</h1><h2 id="1-图像分割的基本概念"><a href="#1-图像分割的基本概念" class="headerlink" title="1. 图像分割的基本概念"></a>1. 图像分割的基本概念</h2><h3 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h3><p>将图像划分为多个互不相交的区域</p>
<h3 id="（2）目标"><a href="#（2）目标" class="headerlink" title="（2）目标"></a>（2）目标</h3><p>根据像素的<strong>相似性</strong>，把具有相似特征的像素组织在一起，识别和分理处不同的对象或区域</p>
<h3 id="（3）超像素"><a href="#（3）超像素" class="headerlink" title="（3）超像素"></a>（3）超像素</h3><p>一个超像素=多个像素形成的小块，例如下图<br><img src="/../images/post13_images/419ac13de61f1c578f43b075854252f9.png"></p>
<h3 id="（4）理想的分割方法"><a href="#（4）理想的分割方法" class="headerlink" title="（4）理想的分割方法"></a>（4）理想的分割方法</h3><p>既不是过分割，也不是欠分割</p>
<ul>
<li>过分割：把一个主体过度分割成多个主体了<br>（超像素属于一种过分割）</li>
<li>欠分割：没有完全分开，把多个主体划分成一个主体了</li>
</ul>
<h3 id="（5）分割方式"><a href="#（5）分割方式" class="headerlink" title="（5）分割方式"></a>（5）分割方式</h3><h4 id="①-自下而上、自上而下"><a href="#①-自下而上、自上而下" class="headerlink" title="① 自下而上、自上而下"></a>① 自下而上、自上而下</h4><h5 id="a-自下而上的分割方法"><a href="#a-自下而上的分割方法" class="headerlink" title="a. 自下而上的分割方法"></a>a. 自下而上的分割方法</h5><ul>
<li>自下：先获取像素的底层特征，例如纹理、边、点</li>
<li>而上：再分割出主体</li>
</ul>
<h5 id="b-自上而下的分割方法"><a href="#b-自上而下的分割方法" class="headerlink" title="b. 自上而下的分割方法"></a>b. 自上而下的分割方法</h5><ul>
<li>自上：先获取一定的图像语义等高层特征</li>
<li>而下：再分割出主体<br>人思考的方式其实就是自上而下</li>
</ul>
<h4 id="②-有监督、无监督"><a href="#②-有监督、无监督" class="headerlink" title="② 有监督、无监督"></a>② 有监督、无监督</h4><ul>
<li>有监督：给标签，从label中学习</li>
<li>无监督，没标签，自己寻找规律<br>人思考的方式其实是有监督+无监督结合的<br>常用深度学习模型基于有监督</li>
</ul>
<h2 id="2-人类做图像分割的原理"><a href="#2-人类做图像分割的原理" class="headerlink" title="2. 人类做图像分割的原理"></a>2. 人类做图像分割的原理</h2><blockquote>
<p>格式塔学派理论</p>
</blockquote>
<p><strong>群组是视觉感知的关键</strong></p>
<h3 id="（1）感知整体空间"><a href="#（1）感知整体空间" class="headerlink" title="（1）感知整体空间"></a>（1）感知整体空间</h3><p>人的视觉系统将元素综合为一个新的领域，相较于部件/元素，更感知整体<br><img src="/../images/post13_images/f8449f17deb8c98418f01a1307012ce2.png"></p>
<h3 id="（2）利用先验知识做判断（自上而下）"><a href="#（2）利用先验知识做判断（自上而下）" class="headerlink" title="（2）利用先验知识做判断（自上而下）"></a>（2）利用先验知识做判断（自上而下）</h3><p>例如下图，人类可能会根据经验，感觉到图像中的事物，比如中间有相交的道路<br><img src="/../images/post13_images/2652c8b5b05e6d40f72140b53082157d.png"></p>
<h3 id="（3）格式塔的组织原则"><a href="#（3）格式塔的组织原则" class="headerlink" title="（3）格式塔的组织原则"></a>（3）格式塔的组织原则</h3><p><img src="/../images/post13_images/c039eae9f50ebe739cddb2575a8489a9.png"><br><img src="/../images/post13_images/a29d58d21dd9b9af1f14265133d778df.png"></p>
<h2 id="3-K-Means-图像分割"><a href="#3-K-Means-图像分割" class="headerlink" title="3. K-Means 图像分割"></a>3. K-Means 图像分割</h2><blockquote>
<p>格式塔学派理论“群组”的思想，恰好对应机器学习的“聚类”任务</p>
</blockquote>
<h3 id="（1）算法流程"><a href="#（1）算法流程" class="headerlink" title="（1）算法流程"></a>（1）算法流程</h3><p><img src="/../images/post13_images/e135158a5bae51c312c717975ba78334.png"></p>
<h3 id="（2）应用实例及问题"><a href="#（2）应用实例及问题" class="headerlink" title="（2）应用实例及问题"></a>（2）应用实例及问题</h3><p><img src="/../images/post13_images/fa6f8069233e6a331df33af8edb39228.png"></p>
<h3 id="（3）影响因素"><a href="#（3）影响因素" class="headerlink" title="（3）影响因素"></a>（3）影响因素</h3><p>初始化聚类中心点的位置（位置不同，算法计算量不同，可能结果也不同）<br>聚类数量K的选取（图中K越大，效果越好，但在具体任务上也有可能出现别的问题，例如过分割~）<br><img src="/../images/post13_images/89ad3df7f68a58c8dcc1798d22785070.png"></p>
<h3 id="（4）优缺点"><a href="#（4）优缺点" class="headerlink" title="（4）优缺点"></a>（4）优缺点</h3><p>优点</p>
<ul>
<li>非常简单</li>
<li>可以收敛到局部最优值<br>缺点</li>
<li>内存需求较大</li>
<li>需要指定K的值，K值的选取影响结果</li>
<li>对初始化随机中心点位置十分敏感</li>
<li>对外点敏感<br><img src="/../images/post13_images/8a283ac112a21bb35c35ef565a94895f.png"></li>
<li>最终只能生成球形的聚类簇（因此在用K-Means时，需要看最终的任务形成的簇大概会是什么形状，K-Means 比较适合最终划分为球形簇的任务）</li>
</ul>
<h2 id="4-Mean-Shift-（均值漂移）-图像分割"><a href="#4-Mean-Shift-（均值漂移）-图像分割" class="headerlink" title="4. Mean Shift （均值漂移） 图像分割"></a>4. Mean Shift （均值漂移） 图像分割</h2><h3 id="（1）算法流程-1"><a href="#（1）算法流程-1" class="headerlink" title="（1）算法流程"></a>（1）算法流程</h3><p><strong>原理：在特征空间中寻找密度模式，或密度的局部最大值</strong><br>一步一步找到密度极大值点：<br><img src="/../images/post13_images/9fe8a240751bbed6d472dcfa5dbabaff.png"></p>
<ul>
<li>查找特征（颜色、纹理等）</li>
<li>在单个特征点初初始化漂移的窗口</li>
<li>对每个窗口执行均值漂移，直到收敛</li>
<li>合并最终接近相同峰值或模式的窗口<br><img src="/../images/post13_images/63c85019d3b12fe92327c3dd2ca4d516.png"></li>
</ul>
<h3 id="（2）优缺点"><a href="#（2）优缺点" class="headerlink" title="（2）优缺点"></a>（2）优缺点</h3><h4 id="a-优点-2"><a href="#a-优点-2" class="headerlink" title="a. 优点"></a>a. 优点</h4><ul>
<li>不需要假设聚类簇的一个球形的（不像K-Means那样），对任何形状都可以聚类</li>
<li>只需要设定一个参数——飘逸的窗口大小</li>
<li>不需要预先设定类别数量（K-Means里的K值），飘逸后找到几个点就代表几个类</li>
<li>对外点比较鲁棒</li>
</ul>
<h4 id="b-缺点-2"><a href="#b-缺点-2" class="headerlink" title="b. 缺点"></a>b. 缺点</h4><ul>
<li>最终输出的结果特别依赖于飘逸窗口大小的设置</li>
<li>计算成本高</li>
<li>如果特征维度太高，表现不太好了</li>
</ul>
<h4 id="c-计算成本高的解决方案"><a href="#c-计算成本高的解决方案" class="headerlink" title="c. 计算成本高的解决方案"></a>c. 计算成本高的解决方案</h4><ul>
<li>对超像素进行Mean Shift，因为超像素本身已经是比较相似的像素的集合，对超像素进行均值漂移就不需要遍历图像中每一个像素了</li>
<li>记录每个漂移框漂移过程中涉及到的所有重心点，当其他框也飘到这个过程中的重心点时，则说明也是那个类（终点是一致的）</li>
</ul>
<h2 id="5-Graph-Cut（图割）图像分割"><a href="#5-Graph-Cut（图割）图像分割" class="headerlink" title="5. Graph Cut（图割）图像分割"></a>5. Graph Cut（图割）图像分割</h2><h3 id="（1）广义框架"><a href="#（1）广义框架" class="headerlink" title="（1）广义框架"></a>（1）广义框架</h3><blockquote>
<p>移除一组边使图分裂为互不连通的子图</p>
</blockquote>
<h4 id="①-准备阶段"><a href="#①-准备阶段" class="headerlink" title="① 准备阶段"></a>① 准备阶段</h4><p>把图像表示成图结构：</p>
<ul>
<li>节点：每个像素对应一个节点</li>
<li>边：相邻像素/满足空间邻近条件的像素对，通过边连接</li>
<li>边权重：像素对的相似性越高，权重越大<br><img src="/../images/post13_images/381359bef2751571e52e60b9336823c2.png"><br>权重涉及到的相似度计算：<br>$$\exp \left( -\frac{1}{2\sigma^2} \text{dist}(x_i, x_j)^2 \right)$$<br>像素表示为特征向量$x_i$，通过上面的公式，将特征向量间的距离映射为相似度（0到1之间）<br>其中：</li>
<li>距离可以用各种距离，例如欧氏距离，L2距离等</li>
<li>$σ$ 控制相似性衰减速率，是一个尺度参数。<ul>
<li>小 $σ$：仅聚集邻近像素，生成细粒度分割（如纹理细节）</li>
<li>大 $σ$：允许远距离像素归为同组，生成粗粒度分割（如整体轮廓）</li>
</ul>
</li>
</ul>
<h4 id="②-割图阶段"><a href="#②-割图阶段" class="headerlink" title="② 割图阶段"></a>② 割图阶段</h4><p>断开图中的低权重边，将图划分为若干子图<br><img src="/../images/post13_images/a60185548c48a3f627df9b48653e2e2f.png"></p>
<h3 id="（3）Minimum-Cut（最小割）"><a href="#（3）Minimum-Cut（最小割）" class="headerlink" title="（3）Minimum Cut（最小割）"></a>（3）Minimum Cut（最小割）</h3><h4 id="①-目标"><a href="#①-目标" class="headerlink" title="① 目标"></a>① 目标</h4><p>割成本：被移除边的权重之和<br>因此最小割想要：找到使割成本最小的分割方式<br><img src="/../images/post13_images/e94ba81e2c91f92fcc196b996e3c29c2.png"></p>
<h4 id="②-局限性"><a href="#②-局限性" class="headerlink" title="② 局限性"></a>② 局限性</h4><p>易切割出孤立小区域（如噪声点），导致过分割<br><img src="/../images/post13_images/b6c959a15f0dcfbccb780589bca6334c.png"></p>
<h3 id="（4）-Normalized-Cut（归一化割）"><a href="#（4）-Normalized-Cut（归一化割）" class="headerlink" title="（4） Normalized Cut（归一化割）"></a>（4） Normalized Cut（归一化割）</h3><blockquote>
<p>最小割倾向于割出很多小区域，这可以根据与每个区域相连所有边的总权重，通过引入归一化因子，平衡分割区域规模</p>
</blockquote>
<h4 id="①-原理-3"><a href="#①-原理-3" class="headerlink" title="① 原理"></a>① 原理</h4><h5 id="a-归一化割的成本"><a href="#a-归一化割的成本" class="headerlink" title="a. 归一化割的成本"></a>a. 归一化割的成本</h5><p>归一化割成本公式：<br>$$\text{Normalized Cut Cost} = \frac{w(A, B)}{w(A, V)} + \frac{w(A, B)}{w(B, V)}$$<br>其中：</p>
<ul>
<li>$w(A,B)$：子图A与B间边权重和</li>
<li>$w(A,V)$：子图A与全图V的边权重和</li>
<li>$w(B,V)$：子图B与全图V的边权重和</li>
</ul>
<p>矩阵表示：<br>$$\text{Normalized Cut Cost} ={\frac{y^T (D - W) y}{y^T D y}}$$<br>其中：</p>
<ul>
<li>$W$：图的邻接矩阵，$n×n$，元素 $W(i,j)$ 表示节点 $i$ 和 $j$ 之间边的权重</li>
<li>$D$：一个对角矩阵，只有对角线上有值，且为 $D(i,i) = \sum_{j} {W}(i,j)$</li>
<li>$D−W$：称为拉普拉斯矩阵，它反映了节点间的差异程度</li>
<li>$y$：指示向量，用于标记每个节点所属的子集。如果第 $i$ 个节点属于子集 $A$，则 $y_i=1$，否则 $y_i$ 为一个负常数，通常设为 $-1$</li>
<li>$y^T(D−W)y$：表示割的代价，即两个子集 $A$ 和 $B$ 之间的边权总和</li>
<li>$y^TDy$：表示区域 $A$ 的总关联度，用于归一化分子部分，避免分割出孤立点或极小区域‘</li>
</ul>
<h5 id="b-归一化割的数学松弛解法"><a href="#b-归一化割的数学松弛解法" class="headerlink" title="b. 归一化割的数学松弛解法"></a>b. 归一化割的数学松弛解法</h5><h6 id="i-原理"><a href="#i-原理" class="headerlink" title="i. 原理"></a>i. 原理</h6><p>直接求解归一化割成本的最优解（最小值）在计算上不可行（指数复杂度）<br>但可以通过放宽离散约束（允许指示向量 $y$ 取任意值），将问题转化为可解的广义特征值问题：<br>$$(D-W)y=\lambda Dy$$<br>解这个问题可以解出许多解：$(\lambda,y)$<br>我们的最终目标：拿到第二小特征值($\lambda$) 所对应的解的 $y$ 值<br>（第一小特征值是 $λ=0$，对应特征向量 $y=[1,1,…,1]^T$，所有像素归为同一类，无意义）<br>这个 $y$ 的值表示了像素的分组倾向，可以根据 $y$ 值分布，使用0或中位数来进行分类（割一刀）（属于哪个子集）</p>
<blockquote>
<p>可以这样理解：平常 $y_i$可能只能取 $+1$ 或 $-1$，但我们可以放宽要求，让 $y_i$ 取任意的正负值，这样就不是绝对二分类，而是类似于对于某个子集的置信度得分（更加可能属于哪个子图）</p>
</blockquote>
<h6 id="ii-算法流程"><a href="#ii-算法流程" class="headerlink" title="ii. 算法流程"></a>ii. 算法流程</h6><ul>
<li>构建图：将图像表示为带权的图 $G=(V,E)$ （节点可能是像素或者超像素），并计算每条边的权重，得到边权重矩阵 $W$ 和 对角矩阵 $D$</li>
<li>特征求解：计算 $(D-W)y=\lambda Dy$ 的第二小特征向量 $y$</li>
<li>割：根据特征向量 $y$ 元素值的分布进行阈值分割</li>
</ul>
<h6 id="iii-扩展到多类割"><a href="#iii-扩展到多类割" class="headerlink" title="iii. 扩展到多类割"></a>iii. 扩展到多类割</h6><p>现在的割是一图割两半<br>也可以扩展到一图一次多割<br>方法有：</p>
<ul>
<li>递归二分：逐层细分（可能引入误差累积）</li>
<li>K-Means聚类：联合多个特征向量（前k个）进行聚类</li>
</ul>
<h5 id="c-效果"><a href="#c-效果" class="headerlink" title="c. 效果"></a>c. 效果</h5><p><img src="/../images/post13_images/77232bdc9a4e330efc5df8c7b178fd1d.png"><br>效果不错捏</p>
<h5 id="d-利用纹理特征进行分割"><a href="#d-利用纹理特征进行分割" class="headerlink" title="d. 利用纹理特征进行分割"></a>d. 利用纹理特征进行分割</h5><blockquote>
<p>如何分割那些是“纹理马赛克”的图像（反正就是因为纹理的问题搞得有点难分割的图像）</p>
</blockquote>
<p>步骤：</p>
<ul>
<li>用一组滤波器组（Filter Bank）对图像进行卷积，提取不同方向和尺度下的纹理特征响应</li>
<li>对所有得到的纹理特征响应，使用聚类算法对特征进行分组，每个聚类中心对应一种纹理的基元</li>
<li>统计窗口内所有像素的纹理基元类别分布，生成基元直方图，直方图的每个bin对应一种基元出现的频率</li>
<li>基元直方图将用于归一化割之中，例如可通过基元直方图来构建 $W$ 矩阵等</li>
</ul>
<p>不过还可能有一种特殊情况：相似纹理跨不同物体（如鹰的羽毛与背景纹理混淆）<br>解决策略：介入轮廓检测。在计算像素间亲和度时，沿连接路径检查是否存在显著边缘（如Canny边缘）</p>
<h5 id="e-归一化割的优缺点"><a href="#e-归一化割的优缺点" class="headerlink" title="e. 归一化割的优缺点"></a>e. 归一化割的优缺点</h5><p>优点：是一个通用的框架，算法流程清晰、固定，可以结合很多其他特征和相似度计算工作<br>缺点：图像存储要求高（不过可以用超像素缓解）、时间复杂度高、倾向于把一个图分为两个部分（如果想得到多个可能需要再多次执行归一化割算法）</p>
<h2 id="6-基于深度学习的弱监督图像分割"><a href="#6-基于深度学习的弱监督图像分割" class="headerlink" title="6. 基于深度学习的弱监督图像分割"></a>6. 基于深度学习的弱监督图像分割</h2><p>有如下几种标住手段，从而不用一点一点描边缘：<br><img src="/../images/post13_images/c1d8aae1b9aa22b9117b9fd0757bde2f.png"></p>
<h1 id="八、识别"><a href="#八、识别" class="headerlink" title="八、识别"></a>八、识别</h1><h2 id="1-图像识别基本概念"><a href="#1-图像识别基本概念" class="headerlink" title="1. 图像识别基本概念"></a>1. 图像识别基本概念</h2><h3 id="（1）涉及到的任务"><a href="#（1）涉及到的任务" class="headerlink" title="（1）涉及到的任务"></a>（1）涉及到的任务</h3><ul>
<li>分类：二分类、多分类</li>
<li>检测：包含两个部分：定位+分类（先得到位置信息，再判断是啥东西）</li>
<li>分割；语义分割（例如，结合了语义描述，某个类别是人，另一个类别是狗。。）、实例分割（人和人不一样，小美小帅）</li>
<li>类别识别和单实例识别</li>
<li>行为或事件识别<blockquote>
<p>理解单实例：就比如拍了个华电西门，虽然都是门，但是花店西门跟别人家学校的门不一样，它就是门的一个单独的实例，具体它自己独立的含义~</p>
</blockquote>
</li>
</ul>
<h3 id="（2）图像识别算法应当解决的问题"><a href="#（2）图像识别算法应当解决的问题" class="headerlink" title="（2）图像识别算法应当解决的问题"></a>（2）图像识别算法应当解决的问题</h3><ul>
<li>对图像或视频进行分类（视频可以切成帧来做分类任务）</li>
<li>对物体进行检测和定位</li>
<li>评估语义和几何特征</li>
<li>分析人类的行为和事件</li>
</ul>
<h3 id="（3）图像识别的难点"><a href="#（3）图像识别的难点" class="headerlink" title="（3）图像识别的难点"></a>（3）图像识别的难点</h3><ul>
<li>种类问题——世界上那么多种类的事物，怎么才能学习到这么多种</li>
<li>视角问题——从不同的视角得到的同一个图像，怎么才能识别成功</li>
<li>光照问题——同一个图像的光照不同，怎么才能识别成功</li>
<li>尺度问题——怎么让算法能够对抗尺度变化（缩放）</li>
<li>形变问题——怎么让算法能够对抗形状的变化（一只小猫咪、一坨小猫咪、一条小猫咪、一摊小猫咪…….）</li>
<li>遮挡问题——怎么让算法能够对抗遮挡（带了口罩怎么才能认出我是我）</li>
<li>背景杂波问题——长得跟背景也太像了，咋区分呢，像下图这样<br><img src="/../images/post13_images/fe6edd4158b30643c0a627f3c0500f47.png"></li>
<li>人为设计问题——同样是椅子，有好多种设计形态呢，设计师灵感不灭，椅子形态总会更新</li>
</ul>
<h2 id="2-图像识别算法设计"><a href="#2-图像识别算法设计" class="headerlink" title="2. 图像识别算法设计"></a>2. 图像识别算法设计</h2><h3 id="（0）设计识别算法需要考虑的问题"><a href="#（0）设计识别算法需要考虑的问题" class="headerlink" title="（0）设计识别算法需要考虑的问题"></a>（0）设计识别算法需要考虑的问题</h3><ul>
<li>表达：怎么表达图像类别</li>
<li>学习：怎么学习给定的数据，得到模型</li>
<li>识别：怎么在崭新的数据上应用学习好的模型</li>
</ul>
<h3 id="（1）表达–Representation"><a href="#（1）表达–Representation" class="headerlink" title="（1）表达–Representation"></a>（1）表达–Representation</h3><h4 id="①-表达的方式"><a href="#①-表达的方式" class="headerlink" title="① 表达的方式"></a>① 表达的方式</h4><p>先划分成小块，有下面很多种划分成小块的方式：<br><img src="/../images/post13_images/330f1616751e8518f926160b710fb803.png"><br>然后放入一个词袋中（像一块拼图），可附加一些语义信息等（每个小块之间可能有关联，从而能根据这些关联拼凑出要识别的东西），拼凑出识别物体，从而表达了图像<br><img src="/../images/post13_images/d7cf7fa366f0df781a1f68c820704e59.png"></p>
<h4 id="②-理想的表达能具备的效果"><a href="#②-理想的表达能具备的效果" class="headerlink" title="② 理想的表达能具备的效果"></a>② 理想的表达能具备的效果</h4><h5 id="不变性（Invariance）"><a href="#不变性（Invariance）" class="headerlink" title="不变性（Invariance）"></a>不变性（Invariance）</h5><p>视角不变性、光照强度不变性、遮挡不变性、尺度不变性、形变不变性、背景杂波不变性……</p>
<h4 id="③-图像识别任务选取的模型"><a href="#③-图像识别任务选取的模型" class="headerlink" title="③ 图像识别任务选取的模型"></a>③ 图像识别任务选取的模型</h4><p>对于这种内类的变化（同一类别中不同样本之间的差异性，比如对于猫类，有狸花猫、布偶猫、奶牛猫…），<strong>概率模型</strong>更为有效<br>概率模型有下面三种</p>
<h5 id="a-生成式模型（Generative-Model）"><a href="#a-生成式模型（Generative-Model）" class="headerlink" title="a. 生成式模型（Generative Model）"></a>a. 生成式模型（Generative Model）</h5><blockquote>
<p>区分张三和李四，先知道他们都具体长啥样，然后区分开</p>
</blockquote>
<p>思想：建模数据本身的分布，学习“如何生成这个类别的样本”<br>根据先验（自然本身就有的规律）和似然来建模<br>常见模型：朴素贝叶斯、层次化贝叶斯（潜在迪利克雷分布）….</p>
<h5 id="b-判别式模型（Discriminative-Model）"><a href="#b-判别式模型（Discriminative-Model）" class="headerlink" title="b. 判别式模型（Discriminative Model）"></a>b. 判别式模型（Discriminative Model）</h5><blockquote>
<p>区分张三和李四，不管他俩长啥样，只要找到一个差异能分开他俩就行</p>
</blockquote>
<p>思想：直接学习类别之间的边界，不关心数据如何生成<br>根据后验（从结果观察到总结出的规律）来建模<br>常见模型：近邻分类法、神经网络、支持向量机及其衍生算法、Boosting…</p>
<h4 id="④-BoF（Bag-of-Features）方法"><a href="#④-BoF（Bag-of-Features）方法" class="headerlink" title="④ BoF（Bag of Features）方法"></a>④ BoF（Bag of Features）方法</h4><blockquote>
<p>借鉴了文本处理中的词袋BoW（Bag of Words）模型，将图像视为由多个局部特征组成的集合，类似于文档中的词汇</p>
</blockquote>
<h5 id="a-步骤"><a href="#a-步骤" class="headerlink" title="a. 步骤"></a>a. 步骤</h5><h6 id="i-特征提取"><a href="#i-特征提取" class="headerlink" title="i.特征提取"></a>i.特征提取</h6><ul>
<li>先提取图像特征，可以用规则网格，也可以用显著性检测只提取感兴趣区域<br><img src="/../images/post13_images/790ad64870e0931d3fdda655a407a070.png"></li>
<li>根据提取到的特征，用聚类算法（例如K-Means）进行聚类<br><img src="/../images/post13_images/6405c09e2018f6e4f3860ace791c73d9.png"></li>
</ul>
<h5 id="ii-学习“视觉词汇”"><a href="#ii-学习“视觉词汇”" class="headerlink" title="ii. 学习“视觉词汇”"></a>ii. 学习“视觉词汇”</h5><p><strong>码本生成（Codebook Learning）：刚才聚类得到的每个特征向量聚簇的聚类中心，称为码向量（Codevector），即视觉词汇；所有码向量构成码本（Codebook），即视觉词汇表（Visual Vocabulary）</strong><br>  <img src="/../images/post13_images/27d72fcc4d739d0e53b4f9678469d291.png"><br>涉及的问题与解决：</p>
<ul>
<li>词汇量选择：<ul>
<li>过小：视觉词无法覆盖所有特征（如蝴蝶翅膀纹理差异被忽略）</li>
<li>过大：量化噪声增加（相似特征被分到不同类），导致过拟合</li>
</ul>
</li>
<li>传统K-means聚类随词汇量增长计算量激增</li>
</ul>
<p>解决：</p>
<ul>
<li>词汇树（Vocabulary Trees, Nister &amp; Stewenius, 2006）：分层聚类结构，通过树状搜索加速最近邻匹配</li>
</ul>
<h5 id="iii-用“视觉词”频率表示图像"><a href="#iii-用“视觉词”频率表示图像" class="headerlink" title="iii. 用“视觉词”频率表示图像"></a>iii. 用“视觉词”频率表示图像</h5><ul>
<li>码本（视觉词汇表）可以表示图像</li>
<li>将新特征映射到码本中最接近的码向量索引（离散化表示），例如：特征向量→索引3（代表“车轮”视觉词）</li>
</ul>
<h5 id="c-混合模型（Hybrid-Model）"><a href="#c-混合模型（Hybrid-Model）" class="headerlink" title="c. 混合模型（Hybrid Model）"></a>c. 混合模型（Hybrid Model）</h5><p>思想：结合生成式与判别式模型的优势<br>平衡先验与后验，通过隐变量或联合优化融合两类模型优势</p>
<h3 id="（2）学习–-Learning"><a href="#（2）学习–-Learning" class="headerlink" title="（2）学习– Learning"></a>（2）学习– Learning</h3><p>关注的问题有：</p>
<ul>
<li>学习参数</li>
<li>监督信息的级别（手动分割、边界框、图像打标签、噪声标签）</li>
<li>批量（batch）/增量（incremental）</li>
<li>先验（领域知识、专业知识）</li>
<li>训练时可能遇到的问题：过拟合、负样本<blockquote>
<p>批量学习：一次性加载全部训练数据（如10000张图片），完成整个数据集遍历后才更新模型参数<br>增量学习：逐步接收新数据（如每天新增100张图片），每接收一个/小批样本就立即更新<br>负样本是指与目标类别相反的参照数据。它们的作用是帮助模型建立区分边界，通过对比学习使模型更精准地识别正样本。</p>
</blockquote>
</li>
</ul>
<h3 id="（3）识别–-Recognition"><a href="#（3）识别–-Recognition" class="headerlink" title="（3）识别– Recognition"></a>（3）识别– Recognition</h3><h4 id="①-识别任务"><a href="#①-识别任务" class="headerlink" title="① 识别任务"></a>① 识别任务</h4><p>见1.（1）</p>
<h4 id="②-搜索策略"><a href="#②-搜索策略" class="headerlink" title="② 搜索策略"></a>② 搜索策略</h4><p>滑动窗口，通过不同尺度（S）、位置（x,y）、旋转角度（θ）的窗口遍历图像</p>
<h4 id="③-搜索策略存在的问题"><a href="#③-搜索策略存在的问题" class="headerlink" title="③ 搜索策略存在的问题"></a>③ 搜索策略存在的问题</h4><h5 id="a-计算复杂度"><a href="#a-计算复杂度" class="headerlink" title="a. 计算复杂度"></a>a. 计算复杂度</h5><p>窗口数=位置(x,y)×尺度(S)×角度(θ)×类别(N)，导致计算量爆炸<br>解决：</p>
<ul>
<li>Lampert et al. BSW (2008)：基于分支定界法（Branch and Bound）的 BSW (Branch-and-Bound with Subwindows) 方法，通过智能剪枝减少无效窗口计算</li>
<li>Alexe et al. (2010)：改进候选区域生成（Objectness），预筛无关区域提升效率</li>
</ul>
<h5 id="b-定位困难"><a href="#b-定位困难" class="headerlink" title="b. 定位困难"></a>b. 定位困难</h5><p>传统检测方法默认用矩形框（Bounding Box）标注物体，但实际物体形状复杂（如弯曲的动物肢体、树枝、服装褶皱等）<br>矩形框无法贴合非规则物体边缘，且滑动窗口可能将相似纹理/颜色的背景区域误判为物体，导致误报<br>解决：</p>
<ul>
<li>非极大值抑制 NMS：合并重叠检测框，仅保留置信度最高的结果</li>
<li>用Canny边缘检测辅助：通过提取物体边缘轮廓（如狗与背景的边界），辅助判断检测框是否贴合真实形状（减少“框住空气”的误报）</li>
<li>引入语义分割技术：不再依赖矩形框，而是逐像素标注物体所属类别（如“狗”像素 vs “人”像素）</li>
</ul>
<h1 id="九、检测"><a href="#九、检测" class="headerlink" title="九、检测"></a>九、检测</h1><blockquote>
<p>聚焦于图像的位置→找一个模板，在图像中滑动窗口检测，区分是否存在我们要找的对象<br>【检测任务→分类任务（每个框是否有我们要找的对象）】</p>
</blockquote>
<h2 id="1-目标检测的难点"><a href="#1-目标检测的难点" class="headerlink" title="1. 目标检测的难点"></a>1. 目标检测的难点</h2><h3 id="（1）可能遇到的问题"><a href="#（1）可能遇到的问题" class="headerlink" title="（1）可能遇到的问题"></a>（1）可能遇到的问题</h3><p>可能受以下影响：</p>
<ul>
<li>光照强度</li>
<li>物体的姿势</li>
<li>背景杂波</li>
<li>遮挡</li>
<li>视角</li>
<li>非物体（即其他部分如背景）干扰</li>
<li>目标特征相似度</li>
<li>….</li>
</ul>
<h3 id="（2）设计算法需要解决的问题"><a href="#（2）设计算法需要解决的问题" class="headerlink" title="（2）设计算法需要解决的问题"></a>（2）设计算法需要解决的问题</h3><h4 id="①-如何高效搜索可能的对象"><a href="#①-如何高效搜索可能的对象" class="headerlink" title="① 如何高效搜索可能的对象"></a>① 如何高效搜索可能的对象</h4><p>可能需要成千上万的窗口，计算量庞大，怎么办</p>
<h4 id="②-特征的设计和评分"><a href="#②-特征的设计和评分" class="headerlink" title="② 特征的设计和评分"></a>② 特征的设计和评分</h4><ul>
<li>外观如何建模</li>
<li>哪些特征与要检测的对象有联系</li>
</ul>
<h4 id="③-怎么处理不同的视角"><a href="#③-怎么处理不同的视角" class="headerlink" title="③ 怎么处理不同的视角"></a>③ 怎么处理不同的视角</h4><ul>
<li>传统为不同的视角建立各自的检测模型</li>
</ul>
<h2 id="2-人脸检测-（Face-Detection）"><a href="#2-人脸检测-（Face-Detection）" class="headerlink" title="2. 人脸检测 （Face Detection）"></a>2. 人脸检测 （Face Detection）</h2><h3 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h3><p>基于滑动窗口法的人脸检测：</p>
<ul>
<li>一方面，框不断滑动位置，寻找人脸</li>
<li>另一方面，框也会不断更改尺寸，因为不知道人脸在图像中的大小<br><img src="/../images/post13_images/60d4a36ad7f3415204095a12bcd45695.png"></li>
</ul>
<h3 id="（2）人脸检测的难点"><a href="#（2）人脸检测的难点" class="headerlink" title="（2）人脸检测的难点"></a>（2）人脸检测的难点</h3><h4 id="①-滑动窗口计算量庞大"><a href="#①-滑动窗口计算量庞大" class="headerlink" title="① 滑动窗口计算量庞大"></a>① 滑动窗口计算量庞大</h4><p>成千上万的位置，太多了<br>解决：由于人脸在图像中是少量的，为了提高计算效率，希望在非面部窗口上花的时间越少越好</p>
<h4 id="②-怎么降低假阳性（False-Positive）"><a href="#②-怎么降低假阳性（False-Positive）" class="headerlink" title="② 怎么降低假阳性（False Positive）"></a>② 怎么降低假阳性（False Positive）</h4><p>False Positive：把不是人脸的检测成人脸了</p>
<h3 id="（3）Viola-Jones算法"><a href="#（3）Viola-Jones算法" class="headerlink" title="（3）Viola &amp; Jones算法"></a>（3）Viola &amp; Jones算法</h3><blockquote>
<p>基于boosting原理的人脸检测</p>
</blockquote>
<h4 id="①-Boosting"><a href="#①-Boosting" class="headerlink" title="①  Boosting"></a>①  Boosting</h4><h5 id="a-为什么选用Boosting"><a href="#a-为什么选用Boosting" class="headerlink" title="a. 为什么选用Boosting"></a>a. 为什么选用Boosting</h5><ul>
<li>能得到较鲁棒的分类器，且简单</li>
<li>是一个提供稀疏视觉特征选择的有效算法</li>
<li>易于实现，不需要外部优化工具、</li>
</ul>
<h5 id="b-原理-1"><a href="#b-原理-1" class="headerlink" title="b. 原理"></a>b. 原理</h5><p>图示：<br><img src="/../images/post13_images/d55ff588e6a832c0e6443ea860786f27.png"><br>公式：<br><img src="/../images/post13_images/6c7f1bf2f95db11aef1f47bd2938e52b.png"><br>其中：<br><img src="/../images/post13_images/d34375f418f3a3bbf17f4bd6112342f6.png"></p>
<h4 id="②-Viola-Jones算法核心特性"><a href="#②-Viola-Jones算法核心特性" class="headerlink" title="② Viola &amp; Jones算法核心特性"></a>② Viola &amp; Jones算法核心特性</h4><ul>
<li>实时目标检测的”范式级”方法</li>
<li>训练过程缓慢（需处理大量数据），但检测速度极快（适合实时应用）</li>
</ul>
<h4 id="③-Viola-Jones算法流程"><a href="#③-Viola-Jones算法流程" class="headerlink" title="③ Viola &amp; Jones算法流程"></a>③ Viola &amp; Jones算法流程</h4><h5 id="a-用积分图加速特征提取并获取弱分类器"><a href="#a-用积分图加速特征提取并获取弱分类器" class="headerlink" title="a. 用积分图加速特征提取并获取弱分类器"></a>a. 用积分图加速特征提取并获取弱分类器</h5><p>如图的四种矩形可以通过计算黑白区域像素差，来捕捉图像特征<br><img src="/../images/post13_images/58355c401c2248cd50585ced7b450db5.png"><br>特征太多了，24x24窗口内16万种特征，每个特征需遍历矩形内所有像素求和，直接计算每个特征的时间复杂度为O(n)，太耗时，于是我们采用下面的积分图加速：<br><strong>积分图每个点(x,y)存储的是其左上角所有像素值的和</strong><br>$I_{\sum}(x, y) = \sum_{x’ \leq x, y’ \leq y} i(x’, y’)$<br><img src="/../images/post13_images/7930469d81f30978bcba465eaf2c0fad.png"><br>则对于任意矩形区域，就可以很快求得积分值了：<br><img src="/../images/post13_images/abb903bb5f8772dfeb7bb594cb811463.png"></p>
<h5 id="b-引入Boosting思想构建强分类器"><a href="#b-引入Boosting思想构建强分类器" class="headerlink" title="b. 引入Boosting思想构建强分类器"></a>b. 引入Boosting思想构建强分类器</h5><h6 id="i-构建最优弱分类器–最优滤波器-阈值组合"><a href="#i-构建最优弱分类器–最优滤波器-阈值组合" class="headerlink" title="i. 构建最优弱分类器–最优滤波器+阈值组合"></a>i. 构建最优弱分类器–最优滤波器+阈值组合</h6><p>针对每个矩形特征（如$α₁$），计算其在所有样本上的响应值（$fⱼ(x)$）是否大于阈值 $\theta <em>j$，是则 $h_j(x)=1$，否则$h_j(x)=0$<br><img src="/../images/post13_images/58a759a10af3ab64e76161d7e926d660.png"><br>对权重归一化：$w</em>{t,i} \leftarrow \frac{w_{t,i}}{\sum_{j}^{n} w_{t,j}}$<br>对每个滤波器 $j$，计算所有样本的特征值 $fⱼ(x)$，并遍历候选 $θ$，选择使分类误差最小的 $θⱼ$<br>对每个$hⱼ(x)$和对应的$θⱼ$，计算其在当前权重下的误差$εⱼ$<br>$$\varepsilon_j = \sum_{i} w_i |h_j(x_i) - y_i|$$<br>选择 $εⱼ$ 最小的 $hⱼ(x)$ 作为本轮最优弱分类器 $hₜ$</p>
<h6 id="ii-重新设置权重"><a href="#ii-重新设置权重" class="headerlink" title="ii. 重新设置权重"></a>ii. 重新设置权重</h6><p>计算调整因子 $βₜ$ ：<br>$$\beta_t = \frac{\varepsilon_t}{1 - \varepsilon_t}$$<br>更新样本权重：<br>$$w_{t+1,i} \leftarrow w_{t,i} \beta_t^{1 - |h_t(x_i) - y_i|}$$</p>
<blockquote>
<p>解读一下 $βₜ$ 的意义：<br>对第 $t$ 个样本的，当前弱分类器表现很差（误差大），那么我们是想要让这些分类错误的样本在后面更受关注，分类正确的就不管了，所以如果 $\epsilon _t$ 很小（分的对），那么就应该让它的权重变小。<br>我们的公式，如果 $\epsilon _t$ 很小，$βₜ → 0$，再看更新样本权重的公式，就可以看出正确样本的权重很小了，则错误样本的权重就相对来说大了。<br>注意，这里并不是提高了错误样本的权重，而是降低正确分类样本的权重。</p>
</blockquote>
<h6 id="iii-得到强分类器"><a href="#iii-得到强分类器" class="headerlink" title="iii. 得到强分类器"></a>iii. 得到强分类器</h6><p>$$h(x) = \begin{cases}<br>1 &amp; \sum_{t=1}^{T} \alpha_t h_t(x) &gt; \frac{1}{2} \sum_{t=1}^{T} \alpha_t \<br>0 &amp; \text{otherwise}<br>\end{cases}$$<br>其中：$\alpha_t = \log \frac{1}{\beta_t}$，$\beta_t = \frac{\varepsilon_t}{1 - \varepsilon_t}$</p>
<h5 id="c-利用注意力级联机制快速去除负样本"><a href="#c-利用注意力级联机制快速去除负样本" class="headerlink" title="c. 利用注意力级联机制快速去除负样本"></a>c. 利用注意力级联机制快速去除负样本</h5><p>是一个逐步筛除的过程：<br><img src="/../images/post13_images/0cc6573e2a5d34a083fe7bc1472200aa.png"><br>简单来说，就是一次比一次精细，每次只关注上次不确定的那些样本，这样能够在最开始快速去除很多负样本,并一点一点逐渐降低误报：<br><img src="/../images/post13_images/cf19064f1c660dbe27c5c6deb4d570d4.png"></p>
<h2 id="3-行人检测（Pedestrian-Detection）"><a href="#3-行人检测（Pedestrian-Detection）" class="headerlink" title="3. 行人检测（Pedestrian Detection）"></a>3. 行人检测（Pedestrian Detection）</h2><h3 id="（1）HOG特征"><a href="#（1）HOG特征" class="headerlink" title="（1）HOG特征"></a>（1）HOG特征</h3><p>HOG特征（方向梯度直方图，Histogram of Oriented Gradients） 是一种用于目标检测的传统图像特征描述方法，由Navneet Dalal和Bill Triggs于2005年提出，尤其在行人检测领域表现突出。其核心思想是通过统计图像局部区域的梯度方向分布来描述物体轮廓和形状特征。</p>
<h3 id="（2）Dalal-Triggs-行人检测流程"><a href="#（2）Dalal-Triggs-行人检测流程" class="headerlink" title="（2）Dalal-Triggs 行人检测流程"></a>（2）Dalal-Triggs 行人检测流程</h3><h4 id="①-滑动窗口提取"><a href="#①-滑动窗口提取" class="headerlink" title="① 滑动窗口提取"></a>① 滑动窗口提取</h4><p>在多尺度图像金字塔上，以64x128窗口滑动遍历所有位置</p>
<h4 id="②-HOG特征计算"><a href="#②-HOG特征计算" class="headerlink" title="② HOG特征计算"></a>② HOG特征计算</h4><blockquote>
<p>计算方式PPT里没有，但在这里写一下：</p>
</blockquote>
<blockquote>
<p>1.图像预处理：</p>
<ul>
<li>转为灰度图，并进行伽马校正（减少光照影响）。</li>
<li>（可选）调整图像尺寸，统一输入尺度。</li>
</ul>
</blockquote>
<blockquote>
<p>2.计算梯度：</p>
<ul>
<li>使用水平 ($G_x$) 和垂直 ($G_y$) 方向的Sobel算子计算每个像素的梯度：<br>  梯度幅值 = $\sqrt{G_x^2 + G_y^2}$,   梯度方向 = $\arctan\left(\frac{G_y}{G_x}\right)$</li>
</ul>
</blockquote>
<blockquote>
<p>3.划分细胞单元（Cell）：</p>
<ul>
<li>将图像划分为多个小单元（如8×8像素的Cell）。</li>
<li>对每个Cell内的像素，统计其梯度方向直方图（通常分为9个方向区间，即0°<del>180°或0°</del>360°）。</li>
</ul>
</blockquote>
<blockquote>
<p>4.块（Block）归一化：</p>
<ul>
<li>将相邻的多个Cell组合成一个Block（如2×2的Cell组成16×16像素的Block）。</li>
<li>对Block内所有Cell的直方图进行归一化（如L2归一化），增强对光照和对比度的鲁棒性。</li>
</ul>
</blockquote>
<blockquote>
<p>5.生成特征向量：</p>
<ul>
<li>所有Block的归一化直方图按顺序拼接，形成最终的高维特征向量（例如，64×128的图像按8×8 Cell划&gt;分，每个Block滑动步长8像素，最终特征维度为7×15×36=3780）</li>
</ul>
</blockquote>
<p>对每个窗口提取3780维HOG特征</p>
<h4 id="③-线性SVM分类"><a href="#③-线性SVM分类" class="headerlink" title="③ 线性SVM分类"></a>③ 线性SVM分类</h4><p>使用预训练的SVM权重向量w对窗口打分（：$Score=w^T⋅HOG特征向量+b$）<br>分数高于阈值则判定为行人</p>
<h4 id="④-非极大值抑制"><a href="#④-非极大值抑制" class="headerlink" title="④ 非极大值抑制"></a>④ 非极大值抑制</h4><p>在连续响应图上寻找局部最大值，合并重叠检测框</p>
<h2 id="4-统计模板方法的优缺点"><a href="#4-统计模板方法的优缺点" class="headerlink" title="4. 统计模板方法的优缺点"></a>4. 统计模板方法的优缺点</h2><p>统计模板方法是一类基于手工设计特征与统计学习的目标检测/识别算法，通过分析目标在图像中的统计分布规律（如边缘方向、纹理对比度），构建数学化的特征模板，并利用分类器（如SVM、Adaboost）进行匹配决策。其核心特点是数据驱动但依赖人工先验知识<br>例如上面的HOG+SVM、Viola-Jones</p>
<h3 id="（1）优点"><a href="#（1）优点" class="headerlink" title="（1）优点"></a>（1）优点</h3><ul>
<li>在检测具有标准方向（典型、固定的视角等）的非可变形对象（人脸、汽车、行人）的任务上，表现不错</li>
<li>检测很快</li>
</ul>
<h3 id="（2）缺点"><a href="#（2）缺点" class="headerlink" title="（2）缺点"></a>（2）缺点</h3><ul>
<li>对于高度可变形的事物（比如猫咪，太软了啥形态都有），检测效果可能不太好</li>
<li>抗遮挡能力不强</li>
<li>需要大量的训练数据</li>
</ul>
<h1 id="十、跟踪"><a href="#十、跟踪" class="headerlink" title="十、跟踪"></a>十、跟踪</h1><p>考试不考，时间精力原因暂不梳理</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Fetyloi</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://fetyloi.netlify.app/2025/04/25/post13/">https://fetyloi.netlify.app/2025/04/25/post13/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Fetyloi</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">
                                    <span class="chip bg-color">深度学习</span>
                                </a>
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">
                                    <span class="chip bg-color">计算机视觉</span>
                                </a>
                            
                                <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">
                                    <span class="chip bg-color">人工智能</span>
                                </a>
                            
                                <a href="/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">
                                    <span class="chip bg-color">卷积神经网络</span>
                                </a>
                            
                                <a href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">
                                    <span class="chip bg-color">目标检测</span>
                                </a>
                            
                                <a href="/tags/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/">
                                    <span class="chip bg-color">边缘检测</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    
    <script src="https://giscus.app/client.js"
        data-repo="Cavalier-JR/Cavalier-JR.github.io"
        data-repo-id="R_kgDOOLp0RA"
        data-category="Announcements"
        data-category-id="DIC_kwDOOLp0RM4CotJt"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light_protanopia"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2025/04/25/post13/">
                    <div class="card-image">
                        
                        <img src="/../images/33.png" class="responsive-img" alt="计算机视觉知识点总结（结合cs131）">
                        
                        <span class="card-title">计算机视觉知识点总结（结合cs131）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-04-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">
                        <span class="chip bg-color">深度学习</span>
                    </a>
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">
                        <span class="chip bg-color">计算机视觉</span>
                    </a>
                    
                    <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">
                        <span class="chip bg-color">人工智能</span>
                    </a>
                    
                    <a href="/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">
                        <span class="chip bg-color">卷积神经网络</span>
                    </a>
                    
                    <a href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">
                        <span class="chip bg-color">目标检测</span>
                    </a>
                    
                    <a href="/tags/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/">
                        <span class="chip bg-color">边缘检测</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2025/04/16/post12/">
                    <div class="card-image">
                        
                        <img src="/../images/31.png" class="responsive-img" alt="C盘容量可视化与C盘清理">
                        
                        <span class="card-title">C盘容量可视化与C盘清理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-04-16
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%B7%A5%E5%85%B7%E8%AE%BE%E7%BD%AE/" class="post-category">
                                    工具设置
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%B7%A5%E5%85%B7/">
                        <span class="chip bg-color">工具</span>
                    </a>
                    
                    <a href="/tags/github/">
                        <span class="chip bg-color">github</span>
                    </a>
                    
                    <a href="/tags/%E7%A3%81%E7%9B%98%E5%A4%84%E7%90%86/">
                        <span class="chip bg-color">磁盘处理</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('30')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Fetyloi&#39;s Blog<br />'
            + '文章作者: Fetyloi<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('1'),
            headingSelector: 'h1, h2, h3, h4, h5, h6'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5, h6').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>






    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="13473505814"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='list'
                   preload='auto'
                   volume='0.1'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2025</span>
            
            <span id="year">2025</span>
            <a href="/about" target="_blank">Fetyloi</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">48.8k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2025";
                    var startMonth = "3";
                    var startDate = "20";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Cavalier-JR" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:j.r@ncepu.edu.cn" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=895484845" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 895484845" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!" title="返回顶部">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>

    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    


    <!-- 白天和黑夜主题 -->
<!-- <div class="sum-moon-box">
    <a class="btn-floating btn-large waves-effect waves-light" onclick="switchNightMode()" title="切换主题" >
      <i id="sum-moon-icon" class="fas fa-moon" style="width:48px; height:48px; font-size: 28px;"></i>
    </a>
  </div> -->
  
  <script>
    function switchNightMode() {
      $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
          $('body').hasClass('DarkMode') 
          ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
          : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
          setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
              $(this).remove()
            })
          }, 2e3)
        })
    }
  </script>

<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>
  
     /* 模式判断 */
    <script>
        /* 模式判断 */
        if (localStorage.getItem('isDark') === '1') {
            document.body.classList.add('DarkMode');
            $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')
        } else {
            document.body.classList.remove('DarkMode');
            $('#sum-moon-icon').removeleClass("fa-sun").addClass('fa-moon')
        }
    </script> 
 
   
    <!-- 下面这个是鼠标拖尾，想用的时候取消注释就可以 -->
    <!-- <script src="/js/cursor.js"></script> -->
</body>

</html>
